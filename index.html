<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VistaGeomatics – Grading Check</title>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Montserrat:wght@400;700&display=swap" rel="stylesheet" />

  <!-- PDF Export (Download/Share) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

  <!-- PDF Upload Preview -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.js"></script>

  <style>
    :root{
      --vista-blue:#165f7d;
      --vista-blue-light:#2a7fa3;
      --vista-blue-dark:#0b3045;

      --pass-blue:#1f9cf0;
      --fail-red:#ef4444;

      --bg-body:#eef3f9;
      --bg-card:#ffffff;
      --border-soft:#d6e2f0;

      --text-main:#101827;
      --text-muted:#5b6777;

      --ok:#15803d;
      --bad:#b91c1c;

      --shadow: 0 10px 30px rgba(2, 10, 20, 0.08);
      --radius: 16px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:"Inter", sans-serif;
      background: radial-gradient(circle at top, #f4fbff 0%, var(--bg-body) 55%, #e9f1fb 100%);
      color:var(--text-main);
    }
    .wrap{ max-width: 1180px; margin: 20px auto 60px; padding: 0 16px; }

    .topbar{
      background: linear-gradient(135deg, var(--vista-blue-dark), var(--vista-blue));
      color:#fff;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .topbar-inner{
      display:flex;
      align-items:center;
      gap:16px;
      padding: 16px 18px;
      flex-wrap:wrap;
    }
    .logo{
      width: 54px; height: 54px; border-radius: 12px;
      background: rgba(255,255,255,0.12);
      display:flex; align-items:center; justify-content:center;
      overflow:hidden; flex: 0 0 auto;
    }
    .logo img{ width: 100%; height: 100%; object-fit: contain; padding: 8px; }
    .brand{ flex:1 1 auto; min-width: 220px; }
    .brand .title{
      font-family:"Montserrat", sans-serif;
      font-weight:700; letter-spacing:0.5px;
      font-size: 18px; margin:0; line-height:1.2;
    }
    .brand .subtitle{ margin:4px 0 0; opacity:0.9; font-size: 13px; }

    .pill{
      display:flex; gap:10px; align-items:center;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.22);
      padding:10px 12px; border-radius: 999px;
      flex: 0 0 auto; white-space: nowrap;
    }
    .pill b{ font-weight:700; }

    .grid{
      display:grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 16px;
      margin-top: 16px;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns:1fr; }
      .pill{ width:100%; justify-content:space-between; }
    }

    .card{
      background: var(--bg-card);
      border: 1px solid var(--border-soft);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card-h{
      padding: 14px 16px;
      border-bottom: 1px solid var(--border-soft);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      background: linear-gradient(180deg, #ffffff, #fbfdff);
      flex-wrap: wrap;
    }
    .card-h h2{ margin:0; font-size: 14px; letter-spacing:0.2px; }
    .card-b{ padding: 14px 16px 16px; }

    .formgrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 620px){ .formgrid{ grid-template-columns:1fr; } }

    label{ display:block; font-size: 12px; color: var(--text-muted); margin-bottom: 6px; }

    input, select, textarea{
      width:100%;
      border: 1px solid var(--border-soft);
      border-radius: 12px;
      padding: 10px 10px;
      font-size: 14px;
      outline:none;
      background: rgba(255,255,255,0.82); /* semi-transparent inputs */
      color: var(--text-main);
    }
    textarea{ min-height: 92px; resize: vertical; }

    .btnbar{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }
    .btn{
      appearance:none;
      border: 1px solid rgba(255,255,255,0.0);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight:600;
      cursor:pointer;
      transition: transform 0.05s ease, opacity 0.15s ease, background 0.15s ease;
      user-select:none;
      white-space: nowrap;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ background: linear-gradient(135deg, var(--vista-blue), var(--vista-blue-light)); color:#fff; }
    .btn.ghost{ background: #f4f8fc; border: 1px solid var(--border-soft); color: var(--text-main); }
    .btn.danger{ background: #fff1f2; border: 1px solid #fecdd3; color: var(--bad); }
    .btn:disabled{ opacity:0.65; cursor:not-allowed; }

    .hint{ font-size: 12px; color: var(--text-muted); margin-top: 8px; line-height: 1.35; }

    table{
      width:100%;
      border-collapse: separate;
      border-spacing: 0;
      overflow:hidden;
      border: 1px solid var(--border-soft);
      border-radius: 14px;
    }
    thead th{
      text-align:left;
      font-size: 12px;
      color: var(--text-muted);
      padding: 10px 10px;
      background: #f6fafc;
      border-bottom: 1px solid var(--border-soft);
      white-space: nowrap;
    }
    tbody td{
      padding: 8px 10px;
      border-bottom: 1px solid var(--border-soft);
      vertical-align: middle;
      font-size: 14px;
    }
    tbody tr:last-child td{ border-bottom: none; }

    td .mini{
      padding: 8px 8px;
      border-radius: 10px;
      font-size: 13px;
      background: rgba(255,255,255,0.82); /* semi-transparent */
    }

    .status{
      font-weight: 800;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      display:inline-block;
      border: 1px solid transparent;
      white-space: nowrap;
    }
    .status.ok{ color: var(--ok); background: #eaf7ee; border-color: #c7ecd2; }
    .status.bad{ color: var(--bad); background: #fff1f2; border-color: #fecdd3; }
    .status.na{ color: #475569; background: #eef2f7; border-color: #d6dee9; }

    .delta{ font-weight: 900; letter-spacing:0.1px; }
    .delta.ok{ color: var(--ok); }
    .delta.bad{ color: var(--bad); }
    .delta.na{ color:#475569; }

    .summary{
      display:flex; gap: 12px; flex-wrap:wrap;
      align-items:center; justify-content:space-between;
      margin-top: 10px;
      padding: 12px 12px;
      border: 1px dashed var(--border-soft);
      border-radius: 14px;
      background: #fbfdff;
    }
    .summary .k{ font-size: 12px; color: var(--text-muted); }
    .summary .v{ font-weight: 900; font-size: 14px; }

    /* Templates */
    .templateGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    @media (max-width: 680px){ .templateGrid{ grid-template-columns: 1fr; } }
    .checkRow{
      display:flex;
      gap:10px;
      align-items:flex-start;
      padding:10px 10px;
      border: 1px solid var(--border-soft);
      border-radius: 12px;
      background:#fbfdff;
    }
    .checkRow input{ width:auto; margin-top:2px; }
    .checkRow .t{ font-size: 13px; line-height: 1.25; }
    .checkRow .t b{ display:block; font-size: 12px; color: var(--text-muted); margin-bottom: 2px; }

    /* Plan preview */
    .planPreview{
      border: 1px solid var(--border-soft);
      border-radius: 14px;
      overflow:hidden;
      background:#fff;
      box-shadow: 0 6px 16px rgba(2,10,20,0.06);
    }
    .planStage{
      position: relative;
      width: 100%;
      background:#fff;
      cursor: crosshair;
      user-select: none;
    }
    .planStage img{ width:100%; height:auto; display:block; }

    .marker{
      position:absolute;
      transform: translate(-50%, -100%);
      background: rgba(22,95,125,0.55); /* semi-transparent */
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      color:#fff;
      border: 2px solid rgba(255,255,255,0.9);
      border-radius: 14px;
      padding: 6px 8px;
      box-shadow: 0 8px 18px rgba(2,10,20,0.18);
      pointer-events: auto;
      cursor: pointer;
      white-space: nowrap;
      min-width: 60px;
      text-align:center;
    }
    .marker .pt{ font-size: 12px; font-weight: 900; line-height: 1.05; }
    .marker .el{
      font-size: 11px;
      font-weight: 900;
      margin-top: 2px;
    }
    .marker .el.pass{ color: var(--pass-blue); }
    .marker .el.fail{ color: var(--fail-red); }
    .marker .el.na{ color: rgba(255,255,255,0.85); }

    .marker .dc{ font-size: 10px; font-weight: 800; opacity: 0.92; margin-top: 2px; }

    .marker::after{
      content:"";
      position:absolute;
      left:50%;
      bottom:-10px;
      transform: translateX(-50%);
      width:0; height:0;
      border-left:7px solid transparent;
      border-right:7px solid transparent;
      border-top:10px solid rgba(22,95,125,0.55); /* match transparency */
    }

    .planMeta{
      padding: 10px 12px;
      border-top: 1px solid var(--border-soft);
      background:#fafcff;
      font-size:12px;
      color:#334155;
      display:flex;
      gap:10px;
      justify-content:space-between;
      align-items:center;
      flex-wrap:wrap;
    }

    .inlineToggle{
      display:flex;
      gap:8px;
      align-items:center;
      font-size:12px;
      color: var(--text-muted);
      padding: 8px 10px;
      border: 1px solid var(--border-soft);
      border-radius: 12px;
      background:#fbfdff;
    }
    .inlineToggle input{ width:auto; }

    /* Photos */
    .thumbGrid{
      display:grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 10px;
      margin-top: 12px;
    }
    @media (max-width: 980px){ .thumbGrid{ grid-template-columns: repeat(4, 1fr); } }
    @media (max-width: 520px){ .thumbGrid{ grid-template-columns: repeat(3, 1fr); } }

    .thumb{
      border: 1px solid var(--border-soft);
      border-radius: 12px;
      overflow:hidden;
      background:#fff;
      position: relative;
      aspect-ratio: 1 / 1;
      box-shadow: 0 6px 16px rgba(2,10,20,0.06);
      cursor:pointer;
    }
    .thumb img{ width:100%; height:100%; object-fit: cover; display:block; }
    .thumb .x{
      position:absolute;
      top:6px;
      right:6px;
      width:28px;
      height:28px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.85);
      background: rgba(0,0,0,0.42);
      color:#fff;
      font-weight:900;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      cursor:pointer;
    }
    .thumb .cap{
      position:absolute;
      left:0; right:0; bottom:0;
      padding:6px 8px;
      font-size:11px;
      color:#fff;
      background: linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,0.70));
      line-height:1.2;
      min-height: 30px;
    }

    /* Export host (hidden) */
    #exportHost{
      position: fixed;
      left: -99999px;
      top: 0;
      width: 816px;
      background: #fff;
      color:#101827;
    }
    .report{ padding: 18px 18px 22px; font-family:"Inter", sans-serif; }
    .reportHeader{
      display:flex; gap:12px; align-items:center;
      border-bottom: 2px solid #e5edf7;
      padding-bottom: 12px; margin-bottom: 12px;
    }
    .reportLogo{
      width: 52px; height: 52px; border-radius: 12px;
      border: 1px solid #e5edf7;
      display:flex; align-items:center; justify-content:center;
      overflow:hidden; background:#fff;
    }
    .reportLogo img{ width:100%; height:100%; object-fit:contain; padding:8px; }
    .reportTitle{
      font-family:"Montserrat", sans-serif;
      font-weight:700; letter-spacing:0.5px;
      margin:0; font-size: 16px; color:#0b3045;
    }
    .reportSub{ margin:4px 0 0; font-size: 12px; color:#475569; }

    .reportMeta{
      display:grid; grid-template-columns: 1fr 1fr;
      gap: 8px 12px; margin: 10px 0 14px;
      font-size: 12px; color:#334155;
    }
    .reportMeta b{ color:#0b3045; }

    .reportSectionTitle{
      font-family:"Montserrat", sans-serif;
      font-weight:700; font-size: 13px;
      color:#0b3045; margin: 14px 0 8px;
    }

    .reportTable{
      width:100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    .reportTable th, .reportTable td{
      border: 1px solid #d6dee9;
      padding: 6px 6px;
      vertical-align: top;
    }
    .reportTable th{
      background:#f6fafc;
      color:#334155;
      font-weight:700;
      text-align:left;
      white-space: nowrap;
    }

    .pillSmall{
      display:inline-block;
      padding: 3px 8px;
      border-radius: 999px;
      font-size: 10px;
      font-weight: 900;
      border: 1px solid #d6dee9;
      background:#eef2f7;
      color:#334155;
      white-space:nowrap;
    }
    .pillSmall.ok{ background:#eaf7ee; border-color:#c7ecd2; color:#15803d; }
    .pillSmall.bad{ background:#fff1f2; border-color:#fecdd3; color:#b91c1c; }

    .pageBreak{ page-break-before: always; }

    .planPrintWrap{
      border:1px solid #d6dee9;
      border-radius:12px;
      overflow:hidden;
    }
    .planPrintStage{ position: relative; }
    .planPrintStage img{ width:100%; height:auto; display:block; }

    .planPrintMarker{
      position:absolute;
      transform: translate(-50%, -100%);
      background: rgba(22,95,125,0.55);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      color:#fff;
      border: 2px solid rgba(255,255,255,0.9);
      border-radius: 12px;
      padding: 5px 7px;
      font-weight: 900;
      white-space: nowrap;
      text-align:center;
      min-width: 52px;
    }
    .planPrintMarker .pt{ font-size: 11px; line-height:1.05; }
    .planPrintMarker .el{ font-size: 10px; margin-top:2px; opacity:0.98; font-weight:900; }
    .planPrintMarker .el.pass{ color: var(--pass-blue); }
    .planPrintMarker .el.fail{ color: var(--fail-red); }
    .planPrintMarker .el.na{ color: rgba(255,255,255,0.85); }
    .planPrintMarker .dc{ font-size: 9px; margin-top:2px; opacity:0.92; }

    .planPrintMarker::after{
      content:"";
      position:absolute;
      left:50%;
      bottom:-8px;
      transform: translateX(-50%);
      width:0; height:0;
      border-left:6px solid transparent;
      border-right:6px solid transparent;
      border-top:8px solid rgba(22,95,125,0.55);
    }

    .photoGridPrint{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .photoBig{
      border: 1px solid #d6dee9;
      border-radius: 12px;
      overflow:hidden;
    }
    .photoBig img{ width:100%; height:auto; display:block; }
    .photoBig .label{
      padding: 8px 10px;
      font-size: 11px;
      color:#334155;
      border-top: 1px solid #e5edf7;
      background:#fafcff;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="topbar-inner">
        <div class="logo" title="Vista Geomatics">
          <img src="vista-geomatics.png" alt="Vista Geomatics Logo" />
        </div>

        <div class="brand">
          <p class="title">VISTA GEOMATICS</p>
          <p class="subtitle">Grading Check, Plot Plan vs Field, HI/FS/IFS, Slopes, Notes, Photos, PDF Export</p>
        </div>

        <div class="pill">
          <span><b>Area</b></span>
          <select id="areaSelect" style="width:auto; background: rgba(255,255,255,0.95); color:#0b3045; border:none; border-radius:999px; padding:8px 10px;">
            <option value="calgary">Calgary</option>
            <option value="chestermere">Chestermere</option>
            <option value="airdrie">Airdrie</option>
          </select>
        </div>

        <div class="pill">
          <span><b>Tolerance</b></span>
          <span id="tolLabel">±15 cm</span>
        </div>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <div class="card-h">
          <h2>Job Details</h2>
          <div class="btnbar">
            <button class="btn ghost" id="btnSave" type="button">Save</button>
            <button class="btn ghost" id="btnReset" type="button">Clear</button>
            <button class="btn primary" id="btnPDF" type="button">Export PDF</button>
            <button class="btn primary" id="btnShare" type="button">Share PDF</button>
          </div>
        </div>
        <div class="card-b">
          <div class="formgrid">
            <div>
              <label>Job Number</label>
              <input id="jobNo" placeholder="e.g., 25-0123" autocomplete="off" />
            </div>
            <div>
              <label>Date</label>
              <input id="jobDate" type="date" />
            </div>
            <div>
              <label>Community / Subdivision</label>
              <input id="community" placeholder="e.g., Cornerstone" autocomplete="off" />
            </div>
            <div>
              <label>Address</label>
              <input id="address" placeholder="e.g., 2053–2055 Cornerstone Blvd NE" autocomplete="off" />
            </div>
            <div>
              <label>Lot / Block / Plan</label>
              <input id="lotBlockPlan" placeholder="e.g., Lot 12, Block 3, Plan ____" autocomplete="off" />
            </div>
            <div>
              <label>Crew Chief</label>
              <input id="crewChief" placeholder="Name" autocomplete="off" />
            </div>
          </div>

          <div class="summary" style="margin-top:14px;">
            <div><div class="k">Points Checked</div><div class="v" id="sumPoints">0</div></div>
            <div><div class="k">Fails</div><div class="v" id="sumFails">0</div></div>
            <div><div class="k">Worst Δ (cm)</div><div class="v" id="sumWorst">—</div></div>
            <div><div class="k">Photos</div><div class="v" id="sumPhotos">0</div></div>
          </div>

          <div class="hint">
            Saves on this device. If you attach very large PDFs/photos, storage can fill up. Use screenshots or flattened PDFs when possible.
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-h">
          <h2>Office Summary</h2>
          <div class="btnbar">
            <button class="btn ghost" id="btnGenSummary" type="button">Generate</button>
            <button class="btn primary" id="btnCopySummary" type="button">Copy</button>
          </div>
        </div>
        <div class="card-b">
          <label>Auto-generated summary for office & drafters</label>
          <textarea id="officeSummary" placeholder="Click Generate to build a consistent summary..."></textarea>
          <div class="hint">
            Includes tolerance, pass/fails, worst deltas, slope deltas, templates, and photo count.
          </div>
        </div>
      </div>

      <div class="card" style="grid-column:1/-1;">
        <div class="card-h">
          <h2>Fast Notes (Consistent)</h2>
          <div class="btnbar">
            <button class="btn ghost" id="btnApplyTemplates" type="button">Apply Templates</button>
            <button class="btn ghost" id="btnClearTemplates" type="button">Clear Template Checks</button>
          </div>
        </div>
        <div class="card-b">
          <label>General Notes / Crew Notes</label>
          <textarea id="notes" placeholder="Optional free text. Use templates below for consistent wording..."></textarea>
          <div id="templateGrid" class="templateGrid"></div>
        </div>
      </div>

      <div class="card" style="grid-column: 1 / -1;">
        <div class="card-h">
          <h2>Marked Up Plot Plan (Image or PDF)</h2>
          <div class="btnbar">
            <label class="btn ghost" style="cursor:pointer;">
              Upload Plot Plan
              <input id="planInput" type="file" accept="image/*,application/pdf" style="display:none;">
            </label>
            <button class="btn danger" id="btnClearPlan" type="button">Remove</button>
            <button class="btn ghost" id="btnClearMarkers" type="button">Clear Markers</button>
          </div>
        </div>
        <div class="card-b">
          <div class="hint" style="margin-top:0;">
            Upload plan, then click to place points. Points auto-number 1, 2, 3… You’ll enter Field Elev and Design Elev. Marker field text turns blue (PASS) or red (FAIL).
          </div>

          <div id="planEmpty" style="margin-top:12px; padding:14px; border:1px dashed var(--border-soft); border-radius:14px; background:#fbfdff; color:var(--text-muted);">
            No plot plan attached yet.
          </div>

          <div id="planWrap" style="margin-top:12px; display:none;">
            <div class="planPreview">
              <div class="planStage" id="planStage" title="Click on the plan to add a point">
                <img id="planImg" alt="Marked up plot plan preview" />
              </div>
              <div class="planMeta">
                <div>
                  <b id="planName">—</b>
                  <div id="planType" style="opacity:0.85; margin-top:2px;"></div>
                </div>
                <div class="hint" style="margin:0;">
                  If a PDF won’t load, upload a screenshot image instead.
                </div>
              </div>
            </div>
          </div>

        </div>
      </div>

      <div class="card" style="grid-column: 1 / -1;">
        <div class="card-h">
          <h2>Site Photos</h2>
          <div class="btnbar">
            <label class="btn ghost" style="cursor:pointer;">
              Add Photos
              <input id="photoInput" type="file" accept="image/*" multiple style="display:none;">
            </label>
            <button class="btn danger" id="btnClearPhotos" type="button">Clear Photos</button>
          </div>
        </div>
        <div class="card-b">
          <div class="hint" style="margin-top:0;">
            Thumbnails show here. PDF export includes larger photos, 4 per page, with captions.
          </div>
          <div id="thumbGrid" class="thumbGrid"></div>
        </div>
      </div>

      <div class="card" style="grid-column: 1 / -1;">
        <div class="card-h">
          <h2>Elevation Comparison</h2>
          <div class="btnbar" style="justify-content:space-between; width:100%;">
            <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
              <div class="inlineToggle">
                <input id="fieldNotesMode" type="checkbox" checked />
                <span><b>Field Notes Mode</b>, Field Elev = HI − FS/IFS (if Field Elev blank)</span>
              </div>
              <div class="inlineToggle">
                <input id="autoSortPoints" type="checkbox" checked />
                <span><b>Auto-sort</b>, numeric points in order</span>
              </div>
              <div class="inlineToggle">
                <input id="numericKeypad" type="checkbox" checked />
                <span><b>Numeric keypad</b> on iPad (HI/FS/IFS/Elev)</span>
              </div>
            </div>
            <div class="btnbar" style="justify-content:flex-end;">
              <button class="btn ghost" id="btnAddRow" type="button">Add Row</button>
              <button class="btn danger" id="btnRemoveSelected" type="button">Remove Selected</button>
            </div>
          </div>
        </div>

        <div class="card-b">
          <div class="hint" style="margin-top:0;">
            Δ (cm) = (Field − Design) × 100. Point identifiers and point notes are dropdowns to keep wording consistent.
          </div>

          <div style="margin-top:12px; overflow:auto;">
            <table>
              <thead>
                <tr>
                  <th style="width:44px;">Sel</th>
                  <th style="min-width:210px;">Station / Point</th>
                  <th style="min-width:120px;">HI (m)</th>
                  <th style="min-width:120px;">FS (m)</th>
                  <th style="min-width:120px;">IFS (m)</th>
                  <th style="min-width:150px;">Field Elev</th>
                  <th style="min-width:150px;">Design Elev</th>
                  <th style="min-width:120px;">Δ (cm)</th>
                  <th style="min-width:110px;">Status</th>
                  <th style="min-width:260px;">Point Note</th>
                </tr>
              </thead>
              <tbody id="elevBody"></tbody>
            </table>
          </div>
        </div>
      </div>

      <div class="card" style="grid-column: 1 / -1;">
        <div class="card-h">
          <h2>Slope Calculator (Between Points)</h2>
          <div class="btnbar">
            <button class="btn ghost" id="btnAddSlope" type="button">Add Slope Row</button>
            <button class="btn danger" id="btnRemoveSlopeSelected" type="button">Remove Selected</button>
          </div>
        </div>
        <div class="card-b">
          <div class="hint" style="margin-top:0;">
            Slope % = (Rise / Run) × 100. Design and Field slopes display instantly once points + distance exist.
          </div>

          <div style="margin-top:12px; overflow:auto;">
            <table>
              <thead>
                <tr>
                  <th style="width:44px;">Sel</th>
                  <th style="min-width:220px;">Segment</th>
                  <th style="min-width:180px;">From</th>
                  <th style="min-width:180px;">To</th>
                  <th style="min-width:140px;">Distance (m)</th>
                  <th style="min-width:140px;">Design Slope %</th>
                  <th style="min-width:140px;">Field Slope %</th>
                  <th style="min-width:120px;">Δ Slope %</th>
                </tr>
              </thead>
              <tbody id="slopeBody"></tbody>
            </table>
          </div>
        </div>
      </div>

    </div>
  </div>

  <div id="exportHost" aria-hidden="true"></div>

  <script>
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.js";
    }

    const STORAGE_KEY = "vista_grading_check_full_v4";
    const tolByAreaCm = { calgary: 15, chestermere: 15, airdrie: 10 };

    const STATION_PRESETS = [
      "RMOW","BM","TBM","TP","SETUP","MID","FG","BG",
      "ROW","PL","SW","SE","NW","NE","FL","FR","RL","RR",
      "C/L","DW","GAR","APRON","SWALE","CURB","GB","GUTTER"
    ];

    const POINT_NOTE_PRESETS = [
      "", "Low, requires fill", "High, requires cut", "Regrade and shape to drain",
      "Swale not defined, re-shape", "Tie-in required, verify match", "Curb tie-in check required",
      "Hold, builder review required", "Recheck after regrade", "As-built matches design"
    ];

    const NOTE_TEMPLATES = [
      { id:"tpl_access", title:"Access / Site Condition", text:"Site accessible, no major obstructions impacting shots." },
      { id:"tpl_obstruct", title:"Access / Site Condition", text:"Obstructions present on site, some shots limited, see photos and point notes." },
      { id:"tpl_snow", title:"Weather / Surface", text:"Snow/ice present, measurements taken with caution and limited surface visibility in areas." },
      { id:"tpl_wet", title:"Weather / Surface", text:"Soft/wet soil conditions observed, expect potential settlement/adjustment after compaction." },
      { id:"tpl_equip", title:"Construction Activity", text:"Builder equipment/materials on site during survey, access constraints noted." },
      { id:"tpl_recheck", title:"Follow-up", text:"Recheck required after regrade/adjustment, see out-of-tolerance items." },
      { id:"tpl_hold", title:"Hold", text:"Hold pending builder correction/confirmation, office to review before drafting." }
    ];

    const state = {
      meta: {
        area: "calgary",
        jobNo: "",
        jobDate: "",
        community: "",
        address: "",
        lotBlockPlan: "",
        crewChief: "",
        notes: "",
        templates: {},
        officeSummary: "",
        nextPoint: 1
      },
      plan: null,
      markers: [],
      photos: [],
      elevRows: [],
      slopeRows: []
    };

    // -------- Helpers --------
    function uid(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }

    function todayISO(){
      const d = new Date();
      const yyyy = d.getFullYear();
      const mm = String(d.getMonth()+1).padStart(2,"0");
      const dd = String(d.getDate()).padStart(2,"0");
      return `${yyyy}-${mm}-${dd}`;
    }

    function safeName(s){
      return String(s ?? "")
        .trim()
        .replace(/[\\/:*?"<>|]+/g, "")
        .replace(/\s+/g, " ")
        .replaceAll(" ", "_")
        .slice(0, 80) || "Grading_Check";
    }

    function defaultFileName(ext){
      const job = safeName(state.meta.jobNo || "Job");
      const crew = safeName(state.meta.crewChief || "Crew");
      const date = todayISO();
      return `${job}_${crew}_${date}.${ext}`;
    }

    function parseNumber(v){
      const s = String(v ?? "").trim();
      if (!s) return null;
      const n = Number(s.replace(",", "."));
      return Number.isFinite(n) ? n : null;
    }

    function normalizeElevToMeters(v){
      const n = parseNumber(v);
      if (!Number.isFinite(n)) return null;
      return n > 1000 ? n / 100 : n;
    }

    function fmt(n, d=2){ if (!Number.isFinite(n)) return ""; return Number(n).toFixed(d); }
    function fmtDash(n, d=1){ if (!Number.isFinite(n)) return "—"; return Number(n).toFixed(d); }

    function calcDeltaCm(fieldM, designM){
      if (!Number.isFinite(fieldM) || !Number.isFinite(designM)) return null;
      return (fieldM - designM) * 100;
    }

    function passFail(deltaCmVal, tolCm){
      if (!Number.isFinite(deltaCmVal)) return "N/A";
      return Math.abs(deltaCmVal) <= tolCm ? "PASS" : "FAIL";
    }

    function escapeHtml(s){
      return String(s ?? "")
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
        .replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }

    function isNumericPointName(name){
      const s = String(name || "").trim();
      return /^\d+(\.\d+)?$/.test(s);
    }

    function sortElevRowsIfEnabled(){
      if (!autoSortPoints.checked) return;

      const nonNumeric = [];
      const numeric = [];
      for (const r of state.elevRows){
        if (isNumericPointName(r.pointName)) numeric.push(r);
        else nonNumeric.push(r);
      }
      numeric.sort((a,b) => parseFloat(a.pointName) - parseFloat(b.pointName));
      state.elevRows = [...nonNumeric, ...numeric];
    }

    function slopePercent(elevFromM, elevToM, runM){
      if (!Number.isFinite(elevFromM) || !Number.isFinite(elevToM) || !Number.isFinite(runM) || runM <= 0) return null;
      return ((elevToM - elevFromM) / runM) * 100;
    }

    // Field Notes Mode: HI above + FS/IFS => Field Elev
    function lastHIAbove(rowIndex){
      for (let i = rowIndex; i >= 0; i--){
        const hi = normalizeElevToMeters(state.elevRows[i]?.hi);
        if (Number.isFinite(hi)) return hi;
      }
      return null;
    }

    function computeFieldElevFromNotes(rowIndex){
      const row = state.elevRows[rowIndex];
      const hi = lastHIAbove(rowIndex);
      if (!Number.isFinite(hi)) return null;

      const ifs = parseNumber(row.ifs);
      const fs  = parseNumber(row.fs);

      if (Number.isFinite(ifs)) return hi - ifs;
      if (Number.isFinite(fs))  return hi - fs;
      return null;
    }

    function markerStatusFromVals(fieldElev, designElev){
      const tol = tolByAreaCm[state.meta.area] ?? 15;
      const fieldM = normalizeElevToMeters(fieldElev);
      const designM = normalizeElevToMeters(designElev);
      const dCm = calcDeltaCm(fieldM, designM);
      if (!Number.isFinite(dCm)) return { cls:"na", dCm:null };
      return { cls: (Math.abs(dCm) <= tol ? "pass" : "fail"), dCm };
    }

    // Auto point numbering
    function getMaxNumericPoint(){
      let maxN = 0;
      for (const r of state.elevRows){
        const s = String(r.pointName || "").trim();
        if (/^\d+$/.test(s)) maxN = Math.max(maxN, parseInt(s, 10));
      }
      for (const m of state.markers){
        const s = String(m.point || "").trim();
        if (/^\d+$/.test(s)) maxN = Math.max(maxN, parseInt(s, 10));
      }
      return maxN;
    }
    function nextAutoPoint(){
      if (!Number.isFinite(state.meta.nextPoint) || state.meta.nextPoint < 1){
        state.meta.nextPoint = getMaxNumericPoint() + 1;
        if (state.meta.nextPoint < 1) state.meta.nextPoint = 1;
      }
      const n = state.meta.nextPoint;
      state.meta.nextPoint += 1;
      saveToStorage();
      return String(n);
    }

    // -------- Elements --------
    const areaSelect = document.getElementById("areaSelect");
    const tolLabel = document.getElementById("tolLabel");

    const jobNo = document.getElementById("jobNo");
    const jobDate = document.getElementById("jobDate");
    const community = document.getElementById("community");
    const address = document.getElementById("address");
    const lotBlockPlan = document.getElementById("lotBlockPlan");
    const crewChief = document.getElementById("crewChief");

    const sumPoints = document.getElementById("sumPoints");
    const sumFails = document.getElementById("sumFails");
    const sumWorst = document.getElementById("sumWorst");
    const sumPhotos = document.getElementById("sumPhotos");

    const btnSave = document.getElementById("btnSave");
    const btnReset = document.getElementById("btnReset");
    const btnPDF = document.getElementById("btnPDF");
    const btnShare = document.getElementById("btnShare");

    const officeSummary = document.getElementById("officeSummary");
    const btnGenSummary = document.getElementById("btnGenSummary");
    const btnCopySummary = document.getElementById("btnCopySummary");

    const notes = document.getElementById("notes");
    const templateGrid = document.getElementById("templateGrid");
    const btnApplyTemplates = document.getElementById("btnApplyTemplates");
    const btnClearTemplates = document.getElementById("btnClearTemplates");

    const planInput = document.getElementById("planInput");
    const btnClearPlan = document.getElementById("btnClearPlan");
    const btnClearMarkers = document.getElementById("btnClearMarkers");
    const planWrap = document.getElementById("planWrap");
    const planEmpty = document.getElementById("planEmpty");
    const planStage = document.getElementById("planStage");
    const planImg = document.getElementById("planImg");
    const planName = document.getElementById("planName");
    const planType = document.getElementById("planType");

    const photoInput = document.getElementById("photoInput");
    const btnClearPhotos = document.getElementById("btnClearPhotos");
    const thumbGrid = document.getElementById("thumbGrid");

    const elevBody = document.getElementById("elevBody");
    const btnAddRow = document.getElementById("btnAddRow");
    const btnRemoveSelected = document.getElementById("btnRemoveSelected");

    const slopeBody = document.getElementById("slopeBody");
    const btnAddSlope = document.getElementById("btnAddSlope");
    const btnRemoveSlopeSelected = document.getElementById("btnRemoveSlopeSelected");

    const fieldNotesMode = document.getElementById("fieldNotesMode");
    const autoSortPoints = document.getElementById("autoSortPoints");
    const numericKeypad = document.getElementById("numericKeypad");

    const exportHost = document.getElementById("exportHost");

    // -------- Storage --------
    function saveToStorage(showToast=false){
      try{
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        if (showToast){
          btnSave.textContent = "Saved";
          setTimeout(() => btnSave.textContent = "Save", 900);
        }
      }catch(e){
        alert("Save failed (storage limit). Clear plan/photos or use smaller screenshots/flattened PDFs.");
      }
    }

    function loadFromStorage(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return false;

        state.meta = Object.assign(state.meta, parsed.meta || {});
        state.plan = parsed.plan || null;
        state.markers = Array.isArray(parsed.markers) ? parsed.markers : [];
        state.photos = Array.isArray(parsed.photos) ? parsed.photos : [];
        state.elevRows = Array.isArray(parsed.elevRows) ? parsed.elevRows : [];
        state.slopeRows = Array.isArray(parsed.slopeRows) ? parsed.slopeRows : [];
        return true;
      }catch(e){
        return false;
      }
    }

    // -------- Render: tolerance + summary --------
    function renderTolerance(){
      const tol = tolByAreaCm[state.meta.area] ?? 15;
      tolLabel.textContent = `±${tol} cm`;
    }

    function renderSummary(){
      const tol = tolByAreaCm[state.meta.area] ?? 15;

      let pointsChecked = 0;
      let fails = 0;
      let worstAbs = null;
      let worstSigned = null;

      for (const r of state.elevRows){
        const designM = normalizeElevToMeters(r.designElev);
        const fieldM  = normalizeElevToMeters(r.fieldElev);
        const dCm = calcDeltaCm(fieldM, designM);
        if (!Number.isFinite(dCm)) continue;

        pointsChecked++;
        if (Math.abs(dCm) > tol) fails++;

        const abs = Math.abs(dCm);
        if (worstAbs === null || abs > worstAbs){
          worstAbs = abs;
          worstSigned = dCm;
        }
      }

      sumPoints.textContent = String(pointsChecked);
      sumFails.textContent = String(fails);
      sumWorst.textContent = (worstSigned === null) ? "—" : fmtDash(worstSigned, 1);
      sumPhotos.textContent = String(state.photos.length);
    }

    // -------- Notes templates --------
    function renderTemplates(){
      templateGrid.innerHTML = "";
      for (const t of NOTE_TEMPLATES){
        const checked = !!state.meta.templates[t.id];
        const div = document.createElement("div");
        div.className = "checkRow";
        div.innerHTML = `
          <input type="checkbox" data-tpl="${t.id}" ${checked ? "checked":""} />
          <div class="t">
            <b>${escapeHtml(t.title)}</b>
            ${escapeHtml(t.text)}
          </div>
        `;
        templateGrid.appendChild(div);
      }
    }

    function applyTemplatesToNotes(){
      const chosen = NOTE_TEMPLATES
        .filter(t => state.meta.templates[t.id])
        .map(t => t.text);

      const manual = (notes.value || "").trim();
      const manualLines = manual ? manual.split("\n").map(s => s.trim()).filter(Boolean) : [];

      const all = [...manualLines];
      for (const line of chosen){
        if (!all.includes(line)) all.push(line);
      }

      notes.value = all.join("\n");
      state.meta.notes = notes.value;
    }

    function clearTemplateChecks(){
      state.meta.templates = {};
      renderTemplates();
      saveToStorage();
    }

    // -------- Render: plan --------
    function renderPlan(){
      planStage.querySelectorAll(".marker").forEach(m => m.remove());

      if (!state.plan){
        planWrap.style.display = "none";
        planEmpty.style.display = "block";
        renderSummary();
        return;
      }

      planWrap.style.display = "block";
      planEmpty.style.display = "none";

      planImg.src = state.plan.dataUrl;
      planName.textContent = state.plan.name || "Plot plan";
      planType.textContent = state.plan.kind === "pdf" ? "PDF (page 1 rendered)" : "Image";

      for (const mk of state.markers){
        const { cls, dCm } = markerStatusFromVals(mk.fieldElev, mk.designElev);
        const el = document.createElement("div");
        el.className = "marker";
        el.style.left = mk.xPct + "%";
        el.style.top = mk.yPct + "%";
        el.dataset.id = mk.id;

        const deltaText = Number.isFinite(dCm) ? `${fmtDash(dCm,1)} cm` : "—";

        el.title = `Point ${mk.point} | Field: ${mk.fieldElev} | Design: ${mk.designElev} | Δ: ${deltaText} (click to edit/remove)`;
        el.innerHTML = `
          <div class="pt">${escapeHtml(mk.point)}</div>
          <div class="el ${cls}">${escapeHtml(mk.fieldElev)}</div>
          <div class="dc">${escapeHtml(deltaText)}</div>
        `;
        planStage.appendChild(el);
      }

      renderSummary();
    }

    // -------- Render: photos --------
    function renderPhotos(){
      thumbGrid.innerHTML = "";
      for (const p of state.photos){
        const div = document.createElement("div");
        div.className = "thumb";
        div.dataset.id = p.id;
        div.innerHTML = `
          <img src="${p.dataUrl}" alt="Site photo" />
          <div class="x" title="Remove">×</div>
          <div class="cap">${escapeHtml(p.caption || "")}</div>
        `;
        thumbGrid.appendChild(div);
      }
      renderSummary();
    }

    // -------- Elevations --------
    function stationPresetSelectHtml(row){
      const cur = (row.preset || "").trim();
      const opts = STATION_PRESETS.map(v => {
        const sel = v === cur ? "selected" : "";
        return `<option value="${escapeHtml(v)}" ${sel}>${escapeHtml(v)}</option>`;
      }).join("");

      return `
        <select class="mini" data-k="preset" data-id="${row.id}" data-type="elev">
          <option value="">Preset…</option>
          ${opts}
        </select>
      `;
    }

    function pointNoteSelectHtml(row){
      const cur = (row.pointNote || "").trim();
      const opts = POINT_NOTE_PRESETS.map(v => {
        const sel = v === cur ? "selected" : "";
        const label = v || "Select…";
        return `<option value="${escapeHtml(v)}" ${sel}>${escapeHtml(label)}</option>`;
      }).join("");

      return `
        <select class="mini" data-k="pointNote" data-id="${row.id}" data-type="elev">
          ${opts}
        </select>
      `;
    }

    function numAttrs(){
      // iPad keypad: type=number + inputmode=decimal + step=any
      return numericKeypad.checked ? `type="number" step="any" inputmode="decimal" pattern="[0-9]*"` : `inputmode="decimal"`;
    }

    function renderElevations(fullRebuild=true){
      sortElevRowsIfEnabled();
      if (!fullRebuild){
        renderSummary();
        updateAllSlopesComputed();
        return;
      }

      const tol = tolByAreaCm[state.meta.area] ?? 15;
      elevBody.innerHTML = "";

      for (const row of state.elevRows){
        const designM = normalizeElevToMeters(row.designElev);
        const fieldM  = normalizeElevToMeters(row.fieldElev);
        const dCm     = calcDeltaCm(fieldM, designM);
        const status  = passFail(dCm, tol);

        const deltaClass = status === "PASS" ? "ok" : (status === "FAIL" ? "bad" : "na");
        const statusClass = status === "PASS" ? "ok" : (status === "FAIL" ? "bad" : "na");

        const tr = document.createElement("tr");
        tr.dataset.rowId = row.id;

        tr.innerHTML = `
          <td><input type="checkbox" class="rowSel" data-id="${row.id}"></td>

          <td>
            <div style="display:grid; grid-template-columns: 1fr; gap:6px;">
              ${stationPresetSelectHtml(row)}
              <input class="mini" data-k="pointName" data-id="${row.id}" data-type="elev"
                value="${escapeHtml(row.pointName||"")}" placeholder="Type point (e.g., 1, 2, RMOW)..." />
            </div>
          </td>

          <td>
            <input class="mini" ${numAttrs()} data-k="hi" data-id="${row.id}" data-type="elev" value="${escapeHtml(row.hi||"")}"
              placeholder="HI" />
          </td>

          <td>
            <input class="mini" ${numAttrs()} data-k="fs" data-id="${row.id}" data-type="elev" value="${escapeHtml(row.fs||"")}"
              placeholder="FS" />
          </td>

          <td>
            <input class="mini" ${numAttrs()} data-k="ifs" data-id="${row.id}" data-type="elev" value="${escapeHtml(row.ifs||"")}"
              placeholder="IFS" />
          </td>

          <td>
            <input class="mini" ${numAttrs()} data-k="fieldElev" data-id="${row.id}" data-type="elev" value="${escapeHtml(row.fieldElev||"")}"
              placeholder="Field Elev" />
          </td>

          <td>
            <input class="mini" ${numAttrs()} data-k="designElev" data-id="${row.id}" data-type="elev" value="${escapeHtml(row.designElev||"")}"
              placeholder="Design Elev" />
          </td>

          <td><span class="delta ${deltaClass}" data-role="delta">${Number.isFinite(dCm) ? fmtDash(dCm,1) : "—"}</span></td>
          <td><span class="status ${statusClass}" data-role="status">${status}</span></td>

          <td>${pointNoteSelectHtml(row)}</td>
        `;

        elevBody.appendChild(tr);
      }

      renderSummary();
      renderSlopes(true);
      renderPlan();
    }

    function updateComputedRow(rowId){
      const tr = elevBody.querySelector(`tr[data-row-id="${CSS.escape(rowId)}"]`);
      if (!tr) return;

      const tol = tolByAreaCm[state.meta.area] ?? 15;
      const row = state.elevRows.find(r => r.id === rowId);
      if (!row) return;

      const designM = normalizeElevToMeters(row.designElev);
      const fieldM  = normalizeElevToMeters(row.fieldElev);
      const dCm     = calcDeltaCm(fieldM, designM);
      const status  = passFail(dCm, tol);

      const deltaEl = tr.querySelector('[data-role="delta"]');
      const statusEl = tr.querySelector('[data-role="status"]');

      const deltaClass = status === "PASS" ? "ok" : (status === "FAIL" ? "bad" : "na");
      const statusClass = status === "PASS" ? "ok" : (status === "FAIL" ? "bad" : "na");

      if (deltaEl){
        deltaEl.textContent = Number.isFinite(dCm) ? fmtDash(dCm,1) : "—";
        deltaEl.className = `delta ${deltaClass}`;
      }
      if (statusEl){
        statusEl.textContent = status;
        statusEl.className = `status ${statusClass}`;
      }

      // keep plan marker showing new pass/fail
      const point = String(row.pointName || "").trim();
      if (point){
        const mk = state.markers.find(m => String(m.point||"").trim() === point);
        if (mk){
          mk.fieldElev = row.fieldElev || mk.fieldElev;
          mk.designElev = row.designElev || mk.designElev;
        }
      }

      renderSummary();
      updateAllSlopesComputed();
      renderPlan();
    }

    // -------- Slopes --------
    function pointNameOptions(){
      const names = state.elevRows.map(r => (r.pointName || "").trim()).filter(Boolean);
      const uniq = [];
      const seen = new Set();
      for (const n of names){
        if (!seen.has(n)){ uniq.push(n); seen.add(n); }
      }
      return uniq;
    }

    function selectHtml(rowId, key, current, options){
      const cur = (current || "").trim();
      const opts = options.map(n => {
        const sel = n === cur ? "selected" : "";
        return `<option value="${escapeHtml(n)}" ${sel}>${escapeHtml(n)}</option>`;
      }).join("");
      return `
        <select class="mini" data-type="slope" data-k="${key}" data-id="${rowId}">
          <option value="">Select…</option>
          ${opts}
        </select>
      `;
    }

    function renderSlopes(rebuild=false){
      if (!rebuild){
        updateAllSlopesComputed();
        return;
      }

      const options = pointNameOptions();
      slopeBody.innerHTML = "";

      for (const row of state.slopeRows){
        const tr = document.createElement("tr");
        tr.dataset.rowId = row.id;

        tr.innerHTML = `
          <td><input type="checkbox" class="slopeSel" data-id="${row.id}"></td>
          <td><input class="mini" data-type="slope" data-k="segment" data-id="${row.id}" value="${escapeHtml(row.segment||"")}" placeholder="e.g., Front swale" /></td>
          <td>${selectHtml(row.id, "fromPoint", row.fromPoint, options)}</td>
          <td>${selectHtml(row.id, "toPoint", row.toPoint, options)}</td>
          <td><input class="mini" ${numAttrs()} data-type="slope" data-k="distanceM" data-id="${row.id}" value="${escapeHtml(row.distanceM||"")}" placeholder="Run (m)" /></td>
          <td><span class="delta na" data-role="designSlope">—</span></td>
          <td><span class="delta na" data-role="fieldSlope">—</span></td>
          <td><span class="delta na" data-role="deltaSlope">—</span></td>
        `;
        slopeBody.appendChild(tr);
      }

      updateAllSlopesComputed();
    }

    function updateAllSlopesComputed(){
      for (const r of state.slopeRows) updateSlopeComputed(r.id);
    }

    function updateSlopeComputed(rowId){
      const row = state.slopeRows.find(r => r.id === rowId);
      const tr = slopeBody.querySelector(`tr[data-row-id="${CSS.escape(rowId)}"]`);
      if (!row || !tr) return;

      const from = state.elevRows.find(r => (r.pointName||"").trim() === (row.fromPoint||"").trim());
      const to   = state.elevRows.find(r => (r.pointName||"").trim() === (row.toPoint||"").trim());
      const runM = parseNumber(row.distanceM);

      const designFromM = normalizeElevToMeters(from?.designElev);
      const designToM   = normalizeElevToMeters(to?.designElev);
      const fieldFromM  = normalizeElevToMeters(from?.fieldElev);
      const fieldToM    = normalizeElevToMeters(to?.fieldElev);

      const designSlope = slopePercent(designFromM, designToM, runM);
      const fieldSlope  = slopePercent(fieldFromM, fieldToM, runM);
      const deltaSlope  = (Number.isFinite(designSlope) && Number.isFinite(fieldSlope)) ? (fieldSlope - designSlope) : null;

      tr.querySelector('[data-role="designSlope"]').textContent = Number.isFinite(designSlope) ? fmtDash(designSlope, 2) : "—";
      tr.querySelector('[data-role="fieldSlope"]').textContent  = Number.isFinite(fieldSlope)  ? fmtDash(fieldSlope, 2)  : "—";
      tr.querySelector('[data-role="deltaSlope"]').textContent  = Number.isFinite(deltaSlope)  ? fmtDash(deltaSlope, 2)  : "—";
    }

    // -------- Plan upload (robust) --------
    async function fileToArrayBuffer(file){
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onerror = () => reject(new Error("Read failed"));
        fr.onload = () => resolve(fr.result);
        fr.readAsArrayBuffer(file);
      });
    }

    function compressImageToDataUrl(file, maxDim=1800, quality=0.88){
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onerror = () => reject(new Error("File read failed"));
        fr.onload = () => {
          const img = new Image();
          img.onload = () => {
            const w = img.width, h = img.height;
            const scale = Math.min(1, maxDim / Math.max(w, h));
            const cw = Math.round(w * scale);
            const ch = Math.round(h * scale);

            const canvas = document.createElement("canvas");
            canvas.width = cw;
            canvas.height = ch;
            const ctx = canvas.getContext("2d", { alpha:false });
            ctx.drawImage(img, 0, 0, cw, ch);

            resolve(canvas.toDataURL("image/jpeg", quality));
          };
          img.onerror = () => reject(new Error("Image load failed"));
          img.src = fr.result;
        };
        fr.readAsDataURL(file);
      });
    }

    async function renderPdfFirstPageToDataUrl(file, maxWidth = 1200) {
      if (!window.pdfjsLib) throw new Error("PDF.js did not load (offline or blocked).");

      const ab = await fileToArrayBuffer(file);
      const loadingTask = pdfjsLib.getDocument({
        data: ab,
        disableAutoFetch: true,
        disableStream: true
      });

      const pdf = await loadingTask.promise;
      const page = await pdf.getPage(1);

      const attempts = [maxWidth, 900, 700];
      let lastErr = null;

      for (const w of attempts) {
        try {
          const viewport1 = page.getViewport({ scale: 1 });
          const scale = Math.min(2.0, w / viewport1.width);
          const viewport = page.getViewport({ scale });

          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d", { alpha: false });

          canvas.width = Math.floor(viewport.width);
          canvas.height = Math.floor(viewport.height);

          await page.render({ canvasContext: ctx, viewport }).promise;
          return canvas.toDataURL("image/jpeg", 0.85);
        } catch (err) {
          lastErr = err;
        }
      }

      throw lastErr || new Error("PDF render failed.");
    }

    async function setPlotPlanFromFile(file){
      const isPdf = file.type === "application/pdf" || (file.name || "").toLowerCase().endsWith(".pdf");

      let dataUrl = "";
      let kind = "image";

      if (isPdf){
        kind = "pdf";
        dataUrl = await renderPdfFirstPageToDataUrl(file, 1200);
      } else if (file.type.startsWith("image/")){
        kind = "image";
        dataUrl = await compressImageToDataUrl(file, 1800, 0.88);
      } else {
        throw new Error("Unsupported file type");
      }

      state.plan = { name: file.name || "plot-plan", kind, dataUrl };
      state.markers = [];

      // reset next point based on existing rows/markers
      state.meta.nextPoint = getMaxNumericPoint() + 1;
      if (state.meta.nextPoint < 1) state.meta.nextPoint = 1;

      renderPlan();
      saveToStorage();
    }

    function clearPlan(){
      if (!state.plan) return;
      if (!confirm("Remove the attached plot plan?")) return;
      state.plan = null;
      state.markers = [];
      renderPlan();
      saveToStorage();
    }

    function clearMarkers(){
      if (!state.markers.length) return;
      if (!confirm("Clear all markers from the plot plan?")) return;
      state.markers = [];
      state.meta.nextPoint = getMaxNumericPoint() + 1;
      renderPlan();
      saveToStorage();
    }

    // -------- Markers + upsert rows (AUTO POINTS) --------
    function promptFieldDesignForAutoPoint(autoPoint){
      const field = prompt(`Field elevation for Point ${autoPoint} (e.g., 92.21 or 9221):`, "");
      if (field === null) return null;
      const fieldElev = String(field).trim();
      if (!fieldElev){ alert("Field elevation is required."); return null; }

      const design = prompt(`Design elevation for Point ${autoPoint} (Plot Plan) (e.g., 92.21 or 9221):`, "");
      if (design === null) return null;
      const designElev = String(design).trim();
      if (!designElev){ alert("Design elevation is required."); return null; }

      return { point: String(autoPoint), fieldElev, designElev };
    }

    function upsertPointRow(pointStr, fieldElevStr, designElevStr){
      const p = String(pointStr || "").trim();
      if (!p) return;

      let row = state.elevRows.find(r => String(r.pointName||"").trim() === p);
      if (!row){
        row = { id: uid(), pointName: p, preset:"", hi:"", fs:"", ifs:"", fieldElev:"", designElev:"", pointNote:"" };
        state.elevRows.push(row);
      }

      row.fieldElev  = String(fieldElevStr  || "").trim();
      row.designElev = String(designElevStr || "").trim();

      if (autoSortPoints.checked) renderElevations(true);
      else {
        const tr = elevBody.querySelector(`tr[data-row-id="${CSS.escape(row.id)}"]`);
        if (tr){
          const fe = tr.querySelector('input[data-k="fieldElev"]');
          const de = tr.querySelector('input[data-k="designElev"]');
          if (fe) fe.value = row.fieldElev;
          if (de) de.value = row.designElev;
          updateComputedRow(row.id);
        } else {
          renderElevations(true);
        }
      }

      saveToStorage();
    }

    function addMarkerAtClick(evt){
      if (!state.plan) return;

      const rect = planStage.getBoundingClientRect();
      const x = (evt.clientX - rect.left) / rect.width;
      const y = (evt.clientY - rect.top) / rect.height;

      const xPct = Math.max(0, Math.min(100, x * 100));
      const yPct = Math.max(0, Math.min(100, y * 100));

      const autoPoint = nextAutoPoint();
      const data = promptFieldDesignForAutoPoint(autoPoint);

      if (!data) {
        // rollback counter if cancelled
        state.meta.nextPoint = Math.max(1, (state.meta.nextPoint || 2) - 1);
        saveToStorage();
        return;
      }

      state.markers.push({
        id: uid(),
        xPct,
        yPct,
        point: data.point,
        fieldElev: data.fieldElev,
        designElev: data.designElev
      });

      upsertPointRow(data.point, data.fieldElev, data.designElev);
      renderPlan();
      saveToStorage();
    }

    function editOrRemoveMarker(markerId){
      const mk = state.markers.find(m => m.id === markerId);
      if (!mk) return;

      const action = prompt(`Marker ${mk.point}: type "edit" to change values, or "remove" to delete it.`, "edit");
      if (action === null) return;

      const a = action.trim().toLowerCase();
      if (a === "remove"){
        state.markers = state.markers.filter(m => m.id !== markerId);
        state.meta.nextPoint = getMaxNumericPoint() + 1;
        renderPlan();
        saveToStorage();
        return;
      }

      if (a === "edit"){
        const field = prompt(`Field elevation for Point ${mk.point}:`, mk.fieldElev || "");
        if (field === null) return;
        const design = prompt(`Design elevation for Point ${mk.point}:`, mk.designElev || "");
        if (design === null) return;

        mk.fieldElev = String(field).trim();
        mk.designElev = String(design).trim();

        upsertPointRow(mk.point, mk.fieldElev, mk.designElev);
        renderPlan();
        saveToStorage();
      }
    }

    // -------- Photos --------
    function addPhotos(files){
      const list = Array.from(files || []);
      if (list.length === 0) return;

      (async () => {
        for (const f of list){
          try{
            const dataUrl = await compressImageToDataUrl(f, 1600, 0.85);
            state.photos.push({ id: uid(), dataUrl, caption: "", ts: Date.now() });
          }catch(e){}
        }
        renderPhotos();
        saveToStorage();
      })();
    }

    function clearPhotos(){
      if (!state.photos.length) return;
      if (!confirm("Clear all site photos?")) return;
      state.photos = [];
      renderPhotos();
      saveToStorage();
    }

    // -------- Office Summary --------
    function buildOfficeSummaryText(){
      const tol = tolByAreaCm[state.meta.area] ?? 15;

      let pointsChecked = 0, fails = 0;
      let worstAbs = null, worstSigned = null, worstPoint = null;

      const failLines = [];
      for (const r of state.elevRows){
        const designM = normalizeElevToMeters(r.designElev);
        const fieldM  = normalizeElevToMeters(r.fieldElev);
        const dCm = calcDeltaCm(fieldM, designM);
        if (!Number.isFinite(dCm)) continue;

        pointsChecked++;
        const status = Math.abs(dCm) <= tol ? "PASS" : "FAIL";
        if (status === "FAIL"){
          fails++;
          failLines.push(`${(r.pointName||"").trim()}: ${fmtDash(dCm,1)} cm${r.pointNote ? `, ${r.pointNote}` : ""}`);
        }

        const abs = Math.abs(dCm);
        if (worstAbs === null || abs > worstAbs){
          worstAbs = abs;
          worstSigned = dCm;
          worstPoint = (r.pointName||"").trim() || null;
        }
      }

      const slopeLines = [];
      for (const sr of state.slopeRows){
        const from = state.elevRows.find(r => (r.pointName||"").trim() === (sr.fromPoint||"").trim());
        const to   = state.elevRows.find(r => (r.pointName||"").trim() === (sr.toPoint||"").trim());
        const runM = parseNumber(sr.distanceM);

        const designFromM = normalizeElevToMeters(from?.designElev);
        const designToM   = normalizeElevToMeters(to?.designElev);

        const fieldFromM  = normalizeElevToMeters(from?.fieldElev);
        const fieldToM    = normalizeElevToMeters(to?.fieldElev);

        const designSlope = slopePercent(designFromM, designToM, runM);
        const fieldSlope  = slopePercent(fieldFromM, fieldToM, runM);
        const deltaSlope  = (Number.isFinite(designSlope) && Number.isFinite(fieldSlope)) ? (fieldSlope - designSlope) : null;

        if (Number.isFinite(designSlope) || Number.isFinite(fieldSlope)){
          slopeLines.push(`${(sr.segment||"").trim() || "Slope"} (${(sr.fromPoint||"").trim()}→${(sr.toPoint||"").trim()}): Design ${fmtDash(designSlope,2)}%, Field ${fmtDash(fieldSlope,2)}%, Δ ${fmtDash(deltaSlope,2)}%`);
        }
      }

      const templateTexts = NOTE_TEMPLATES.filter(t => state.meta.templates[t.id]).map(t => t.text);
      const notesText = (state.meta.notes || "").trim();
      const areaName = state.meta.area ? (state.meta.area[0].toUpperCase() + state.meta.area.slice(1)) : "Area";

      const lines = [];
      lines.push(`${areaName} (±${tol} cm). ${pointsChecked} points checked, ${fails} out of tolerance.`);
      if (worstPoint && worstSigned !== null) lines.push(`Largest variance ${fmtDash(worstSigned,1)} cm at ${worstPoint}.`);
      if (failLines.length) lines.push(`Out-of-tolerance items: ${failLines.join("; ")}.`);
      if (slopeLines.length) lines.push(`Slope checks: ${slopeLines.join("; ")}.`);
      lines.push(`${state.photos.length} site photos attached.`);
      if (templateTexts.length) lines.push(templateTexts.join(" "));
      if (notesText) lines.push(`Crew notes: ${notesText}`);

      return lines.join("\n");
    }

    // -------- PDF export + share --------
    function waitImagesLoaded(container){
      const imgs = Array.from(container.querySelectorAll("img"));
      if (imgs.length === 0) return Promise.resolve();
      return Promise.all(imgs.map(img => {
        if (img.complete && img.naturalWidth > 0) return Promise.resolve();
        return new Promise(resolve => {
          const done = () => resolve();
          img.addEventListener("load", done, { once:true });
          img.addEventListener("error", done, { once:true });
        });
      })).then(() => undefined);
    }

    function buildReportElement(){
      exportHost.innerHTML = "";

      const tol = tolByAreaCm[state.meta.area] ?? 15;
      const wrap = document.createElement("div");
      wrap.className = "report";

      const summaryText = (officeSummary.value || "").trim() || buildOfficeSummaryText();

      wrap.innerHTML = `
        <div class="reportHeader">
          <div class="reportLogo"><img src="vista-geomatics.png" alt="Logo"/></div>
          <div>
            <p class="reportTitle">VISTA GEOMATICS, Grading Check Report</p>
            <p class="reportSub">Tolerance: ±${tol} cm</p>
          </div>
        </div>

        <div class="reportMeta">
          <div><b>Job Number:</b> ${escapeHtml(state.meta.jobNo || "")}</div>
          <div><b>Date:</b> ${escapeHtml(state.meta.jobDate || "")}</div>
          <div><b>Community:</b> ${escapeHtml(state.meta.community || "")}</div>
          <div><b>Address:</b> ${escapeHtml(state.meta.address || "")}</div>
          <div><b>Lot/Block/Plan:</b> ${escapeHtml(state.meta.lotBlockPlan || "")}</div>
          <div><b>Crew Chief:</b> ${escapeHtml(state.meta.crewChief || "")}</div>
        </div>

        <div class="reportSectionTitle">Office Summary</div>
        <div style="border:1px solid #d6dee9; border-radius:12px; padding:10px 10px; font-size:11px; color:#334155; white-space:pre-wrap; background:#fbfdff;">${escapeHtml(summaryText)}</div>
      `;

      // Plan page
      if (state.plan){
        const planPage = document.createElement("div");
        planPage.className = "pageBreak";
        planPage.innerHTML = `
          <div class="reportSectionTitle">Marked Up Plot Plan</div>
          <div class="planPrintWrap">
            <div class="planPrintStage" id="planPrintStage">
              <img src="${state.plan.dataUrl}" alt="${escapeHtml(state.plan.name)}" />
            </div>
            <div style="padding:8px 10px; font-size:11px; color:#334155; border-top:1px solid #e5edf7; background:#fafcff;">
              ${escapeHtml(state.plan.name)}
            </div>
          </div>
        `;
        wrap.appendChild(planPage);

        const stage = planPage.querySelector("#planPrintStage");
        for (const mk of state.markers){
          const { cls, dCm } = markerStatusFromVals(mk.fieldElev, mk.designElev);
          const el = document.createElement("div");
          el.className = "planPrintMarker";
          el.style.left = mk.xPct + "%";
          el.style.top = mk.yPct + "%";
          el.innerHTML = `
            <div class="pt">${escapeHtml(mk.point)}</div>
            <div class="el ${cls}">${escapeHtml(mk.fieldElev)}</div>
            <div class="dc">${escapeHtml(Number.isFinite(dCm) ? fmtDash(dCm,1) + " cm" : "—")}</div>
          `;
          stage.appendChild(el);
        }
      }

      // Elevations table
      const elevTitle = document.createElement("div");
      elevTitle.className = "reportSectionTitle";
      elevTitle.textContent = "Elevation Comparison";
      wrap.appendChild(elevTitle);

      const tolCm = tolByAreaCm[state.meta.area] ?? 15;
      const elevTable = document.createElement("table");
      elevTable.className = "reportTable";
      elevTable.innerHTML = `
        <thead>
          <tr>
            <th>Station / Point</th>
            <th>HI</th>
            <th>FS</th>
            <th>IFS</th>
            <th>Field Elev</th>
            <th>Design Elev</th>
            <th>Δ (cm)</th>
            <th>Status</th>
            <th>Point Note</th>
          </tr>
        </thead>
        <tbody>
          ${state.elevRows.map(r => {
            const designM = normalizeElevToMeters(r.designElev);
            const fieldM  = normalizeElevToMeters(r.fieldElev);
            const dCm     = calcDeltaCm(fieldM, designM);
            const status  = passFail(dCm, tolCm);
            const pill = status === "PASS" ? 'pillSmall ok' : (status === "FAIL" ? 'pillSmall bad' : 'pillSmall');
            return `
              <tr>
                <td>${escapeHtml((r.pointName||"").trim())}</td>
                <td>${escapeHtml((r.hi||"").trim())}</td>
                <td>${escapeHtml((r.fs||"").trim())}</td>
                <td>${escapeHtml((r.ifs||"").trim())}</td>
                <td>${escapeHtml((r.fieldElev||"").trim())}</td>
                <td>${escapeHtml((r.designElev||"").trim())}</td>
                <td>${escapeHtml(Number.isFinite(dCm) ? fmtDash(dCm,1) : "—")}</td>
                <td><span class="${pill}">${escapeHtml(status)}</span></td>
                <td>${escapeHtml((r.pointNote||"").trim())}</td>
              </tr>
            `;
          }).join("")}
        </tbody>
      `;
      wrap.appendChild(elevTable);

      // Slopes table
      const slopeTitle = document.createElement("div");
      slopeTitle.className = "reportSectionTitle";
      slopeTitle.textContent = "Slope Summary";
      wrap.appendChild(slopeTitle);

      const slopeTable = document.createElement("table");
      slopeTable.className = "reportTable";
      slopeTable.innerHTML = `
        <thead>
          <tr>
            <th>Segment</th>
            <th>From</th>
            <th>To</th>
            <th>Distance (m)</th>
            <th>Design Slope %</th>
            <th>Field Slope %</th>
            <th>Δ Slope %</th>
          </tr>
        </thead>
        <tbody>
          ${state.slopeRows.map(sr => {
            const from = state.elevRows.find(r => (r.pointName||"").trim() === (sr.fromPoint||"").trim());
            const to   = state.elevRows.find(r => (r.pointName||"").trim() === (sr.toPoint||"").trim());
            const runM = parseNumber(sr.distanceM);

            const designFromM = normalizeElevToMeters(from?.designElev);
            const designToM   = normalizeElevToMeters(to?.designElev);
            const fieldFromM  = normalizeElevToMeters(from?.fieldElev);
            const fieldToM    = normalizeElevToMeters(to?.fieldElev);

            const designSlope = slopePercent(designFromM, designToM, runM);
            const fieldSlope  = slopePercent(fieldFromM, fieldToM, runM);
            const deltaSlope  = (Number.isFinite(designSlope) && Number.isFinite(fieldSlope)) ? (fieldSlope - designSlope) : null;

            return `
              <tr>
                <td>${escapeHtml((sr.segment||"").trim())}</td>
                <td>${escapeHtml((sr.fromPoint||"").trim())}</td>
                <td>${escapeHtml((sr.toPoint||"").trim())}</td>
                <td>${escapeHtml((sr.distanceM||"").trim())}</td>
                <td>${escapeHtml(Number.isFinite(designSlope) ? fmtDash(designSlope,2) : "—")}</td>
                <td>${escapeHtml(Number.isFinite(fieldSlope) ? fmtDash(fieldSlope,2) : "—")}</td>
                <td>${escapeHtml(Number.isFinite(deltaSlope) ? fmtDash(deltaSlope,2) : "—")}</td>
              </tr>
            `;
          }).join("")}
        </tbody>
      `;
      wrap.appendChild(slopeTable);

      // Photos pages (4 per page)
      if (state.photos.length){
        const perPage = 4;
        for (let i = 0; i < state.photos.length; i += perPage){
          const page = document.createElement("div");
          page.className = "pageBreak";
          page.innerHTML = `<div class="reportSectionTitle">Site Photos</div><div class="photoGridPrint"></div>`;
          const grid = page.querySelector(".photoGridPrint");
          for (const p of state.photos.slice(i, i + perPage)){
            const card = document.createElement("div");
            card.className = "photoBig";
            card.innerHTML = `
              <img src="${p.dataUrl}" alt="Photo" />
              <div class="label">${escapeHtml(p.caption || "")}</div>
            `;
            grid.appendChild(card);
          }
          wrap.appendChild(page);
        }
      }

      exportHost.appendChild(wrap);
      return wrap;
    }

    async function exportPDF(){
      if (typeof html2pdf === "undefined"){
        alert("PDF export library failed to load. Connect once and refresh.");
        return;
      }

      const reportEl = buildReportElement();
      await waitImagesLoaded(reportEl);

      const filename = defaultFileName("pdf");

      btnPDF.textContent = "Exporting...";
      btnPDF.disabled = true;

      try{
        await html2pdf()
          .set({
            margin: [10, 10, 10, 10],
            filename,
            image: { type: "jpeg", quality: 0.95 },
            html2canvas: { scale: 2, useCORS: true, backgroundColor: "#ffffff" },
            jsPDF: { unit: "mm", format: "letter", orientation: "portrait" },
            pagebreak: { mode: ["css", "legacy"] }
          })
          .from(reportEl)
          .save();
      } finally{
        btnPDF.textContent = "Export PDF";
        btnPDF.disabled = false;
        exportHost.innerHTML = "";
      }
    }

    async function sharePDF(){
      if (typeof html2pdf === "undefined"){
        alert("Share requires the PDF export library (online once to load).");
        return;
      }

      const reportEl = buildReportElement();
      await waitImagesLoaded(reportEl);
      const filename = defaultFileName("pdf");

      btnShare.textContent = "Preparing...";
      btnShare.disabled = true;

      try{
        const opt = {
          margin: [10, 10, 10, 10],
          image: { type: "jpeg", quality: 0.95 },
          html2canvas: { scale: 2, useCORS: true, backgroundColor: "#ffffff" },
          jsPDF: { unit: "mm", format: "letter", orientation: "portrait" },
          pagebreak: { mode: ["css", "legacy"] }
        };

        const worker = html2pdf().set(opt).from(reportEl);
        const pdfBlob = await worker.outputPdf("blob");
        const file = new File([pdfBlob], filename, { type: "application/pdf" });

        if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })){
          await navigator.share({
            title: "Vista Geomatics – Grading Check",
            text: "Grading check report attached.",
            files: [file]
          });
        } else {
          await html2pdf().set({ ...opt, filename }).from(reportEl).save();
          alert("Share isn't available in this browser, the PDF was downloaded instead.");
        }
      } catch (e) {
      } finally{
        btnShare.textContent = "Share PDF";
        btnShare.disabled = false;
        exportHost.innerHTML = "";
      }
    }

    // -------- Defaults + Sync --------
    function initDefaults(){
      if (!state.meta.templates) state.meta.templates = {};
      if (!state.meta.jobDate) state.meta.jobDate = todayISO();

      if (!Number.isFinite(state.meta.nextPoint) || state.meta.nextPoint < 1){
        state.meta.nextPoint = 1;
      }

      if (state.elevRows.length === 0){
        state.elevRows.push({ id: uid(), pointName: "RMOW", preset:"RMOW", hi:"", fs:"", ifs:"", fieldElev:"", designElev:"", pointNote:"" });
      }
      if (state.slopeRows.length === 0){
        state.slopeRows.push({ id: uid(), segment:"Front swale", fromPoint:"1", toPoint:"2", distanceM:"5.0" });
      }

      // always keep nextPoint aligned with existing numeric points
      state.meta.nextPoint = Math.max(state.meta.nextPoint, getMaxNumericPoint() + 1);
    }

    function syncMetaToUI(){
      areaSelect.value = state.meta.area || "calgary";
      jobNo.value = state.meta.jobNo || "";
      jobDate.value = state.meta.jobDate || "";
      community.value = state.meta.community || "";
      address.value = state.meta.address || "";
      lotBlockPlan.value = state.meta.lotBlockPlan || "";
      crewChief.value = state.meta.crewChief || "";
      notes.value = state.meta.notes || "";
      officeSummary.value = state.meta.officeSummary || "";
    }

    // -------- Events --------
    areaSelect.addEventListener("change", () => {
      state.meta.area = areaSelect.value;
      renderTolerance();
      renderElevations(true);
      saveToStorage();
    });

    function bindMetaInput(el, key){
      el.addEventListener("input", () => {
        state.meta[key] = el.value;
        saveToStorage();
      });
    }
    bindMetaInput(jobNo, "jobNo");
    bindMetaInput(jobDate, "jobDate");
    bindMetaInput(community, "community");
    bindMetaInput(address, "address");
    bindMetaInput(lotBlockPlan, "lotBlockPlan");
    bindMetaInput(crewChief, "crewChief");

    notes.addEventListener("input", () => {
      state.meta.notes = notes.value;
      saveToStorage();
    });

    officeSummary.addEventListener("input", () => {
      state.meta.officeSummary = officeSummary.value;
      saveToStorage();
    });

    templateGrid.addEventListener("change", (e) => {
      const cb = e.target;
      if (!cb?.dataset?.tpl) return;
      state.meta.templates[cb.dataset.tpl] = cb.checked;
      saveToStorage();
    });

    btnApplyTemplates.addEventListener("click", () => {
      applyTemplatesToNotes();
      saveToStorage();
    });

    btnClearTemplates.addEventListener("click", () => clearTemplateChecks());

    fieldNotesMode.addEventListener("change", () => {
      if (fieldNotesMode.checked){
        for (let i = 0; i < state.elevRows.length; i++){
          const r = state.elevRows[i];
          if (String(r.fieldElev || "").trim()) continue;
          const computed = computeFieldElevFromNotes(i);
          if (Number.isFinite(computed)) r.fieldElev = fmt(computed, 2);
        }
      }
      renderElevations(true);
      saveToStorage();
    });

    autoSortPoints.addEventListener("change", () => {
      renderElevations(true);
      saveToStorage();
    });

    numericKeypad.addEventListener("change", () => {
      renderElevations(true);
      renderSlopes(true);
      saveToStorage();
    });

    // Select-all on focus (speeds editing)
    elevBody.addEventListener("focusin", (e) => {
      const t = e.target;
      if (t && t.tagName === "INPUT" && t.dataset?.type === "elev") {
        t.select?.();
      }
    });

    // IMPORTANT: input handler does NOT full-rerender per keystroke
    elevBody.addEventListener("input", (e) => {
      const t = e.target;
      if (!t?.dataset?.id) return;
      if (t.dataset.type !== "elev") return;

      const id = t.dataset.id;
      const k = t.dataset.k;
      const rowIndex = state.elevRows.findIndex(r => r.id === id);
      if (rowIndex < 0) return;

      const row = state.elevRows[rowIndex];
      row[k] = t.value;

      if (fieldNotesMode.checked && (k === "hi" || k === "fs" || k === "ifs")){
        if (!String(row.fieldElev || "").trim()){
          const computed = computeFieldElevFromNotes(rowIndex);
          if (Number.isFinite(computed)){
            row.fieldElev = fmt(computed, 2);
            const tr = elevBody.querySelector(`tr[data-row-id="${CSS.escape(id)}"]`);
            const fe = tr?.querySelector('input[data-k="fieldElev"]');
            if (fe) fe.value = row.fieldElev;
          }
        }
      }

      if (k === "pointName" && autoSortPoints.checked){
        renderElevations(true);
      } else {
        updateComputedRow(id);
      }

      saveToStorage();
    });

    elevBody.addEventListener("change", (e) => {
      const t = e.target;
      if (!t?.dataset?.id) return;
      if (t.dataset.type !== "elev") return;

      const id = t.dataset.id;
      const k = t.dataset.k;
      const row = state.elevRows.find(r => r.id === id);
      if (!row) return;

      if (k === "preset"){
        row.preset = t.value;
        if (t.value){
          row.pointName = t.value;
          const tr = elevBody.querySelector(`tr[data-row-id="${CSS.escape(id)}"]`);
          const pn = tr?.querySelector('input[data-k="pointName"]');
          if (pn) pn.value = row.pointName;
          if (autoSortPoints.checked) renderElevations(true);
          else updateComputedRow(id);
        }
      }

      if (k === "pointNote"){
        row.pointNote = t.value;
      }

      renderSlopes(true);
      saveToStorage();
    });

    btnAddRow.addEventListener("click", () => {
      state.elevRows.push({ id: uid(), pointName: "", preset:"", hi:"", fs:"", ifs:"", fieldElev:"", designElev:"", pointNote:"" });
      renderElevations(true);
      saveToStorage();
    });

    btnRemoveSelected.addEventListener("click", () => {
      const checks = Array.from(document.querySelectorAll(".rowSel:checked"));
      const ids = new Set(checks.map(c => c.dataset.id));
      state.elevRows = state.elevRows.filter(r => !ids.has(r.id));
      state.meta.nextPoint = getMaxNumericPoint() + 1;
      renderElevations(true);
      saveToStorage();
    });

    // Slopes (live)
    slopeBody.addEventListener("input", (e) => {
      const t = e.target;
      if (!t?.dataset?.id) return;
      if (t.dataset.type !== "slope") return;

      const id = t.dataset.id;
      const k = t.dataset.k;
      const row = state.slopeRows.find(r => r.id === id);
      if (!row) return;

      row[k] = t.value;
      updateSlopeComputed(id);
      saveToStorage();
    });

    slopeBody.addEventListener("change", (e) => {
      const t = e.target;
      if (!t?.dataset?.id) return;
      if (t.dataset.type !== "slope") return;

      const id = t.dataset.id;
      const k = t.dataset.k;
      const row = state.slopeRows.find(r => r.id === id);
      if (!row) return;

      row[k] = t.value;
      renderSlopes(true);
      saveToStorage();
    });

    btnAddSlope.addEventListener("click", () => {
      state.slopeRows.push({ id: uid(), segment:"", fromPoint:"", toPoint:"", distanceM:"" });
      renderSlopes(true);
      saveToStorage();
    });

    btnRemoveSlopeSelected.addEventListener("click", () => {
      const checks = Array.from(document.querySelectorAll(".slopeSel:checked"));
      const ids = new Set(checks.map(c => c.dataset.id));
      state.slopeRows = state.slopeRows.filter(r => !ids.has(r.id));
      renderSlopes(true);
      saveToStorage();
    });

    btnSave.addEventListener("click", () => saveToStorage(true));

    btnReset.addEventListener("click", () => {
      if (!confirm("Clear this grading check from this device?")) return;
      localStorage.removeItem(STORAGE_KEY);

      state.meta = { area:"calgary", jobNo:"", jobDate:todayISO(), community:"", address:"", lotBlockPlan:"", crewChief:"", notes:"", templates:{}, officeSummary:"", nextPoint:1 };
      state.plan = null;
      state.markers = [];
      state.photos = [];
      state.elevRows = [];
      state.slopeRows = [];

      initDefaults();
      syncMetaToUI();

      renderTolerance();
      renderTemplates();
      renderPlan();
      renderPhotos();
      renderElevations(true);
      saveToStorage();
    });

    btnPDF.addEventListener("click", () => exportPDF());
    btnShare.addEventListener("click", () => sharePDF());

    btnGenSummary.addEventListener("click", () => {
      const text = buildOfficeSummaryText();
      officeSummary.value = text;
      state.meta.officeSummary = text;
      saveToStorage();
    });

    btnCopySummary.addEventListener("click", async () => {
      const text = (officeSummary.value || "").trim() || buildOfficeSummaryText();
      try{
        await navigator.clipboard.writeText(text);
      }catch(e){
        officeSummary.focus();
        officeSummary.select();
        document.execCommand("copy");
      }
    });

    // Plot plan upload
    planInput.addEventListener("change", async (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;

      try {
        await setPlotPlanFromFile(f);
      } catch (err) {
        const msg = String(err?.message || err || "");
        if (msg.toLowerCase().includes("pdf.js")) {
          alert("Plot plan upload failed because the PDF viewer library didn’t load. If you’re offline or the network blocks CDNs, upload a screenshot (image) instead.");
        } else if (msg.toLowerCase().includes("password") || msg.toLowerCase().includes("encrypted")) {
          alert("This PDF appears to be protected. Please Print to PDF (flatten) and upload the new file, or upload a screenshot.");
        } else {
          alert("Could not process this PDF. Try: Print to PDF (flatten), export a lower-resolution PDF, or upload a screenshot image.\n\nDetails: " + msg);
        }
      } finally {
        planInput.value = "";
      }
    });

    btnClearPlan.addEventListener("click", () => clearPlan());
    btnClearMarkers.addEventListener("click", () => clearMarkers());

    // Click-to-add markers
    planStage.addEventListener("click", (e) => {
      const mk = e.target.closest(".marker");
      if (mk) return;
      addMarkerAtClick(e);
    });
    planStage.addEventListener("click", (e) => {
      const mk = e.target.closest(".marker");
      if (!mk) return;
      editOrRemoveMarker(mk.dataset.id);
    });

    // Photos upload
    photoInput.addEventListener("change", (e) => {
      addPhotos(e.target.files);
      photoInput.value = "";
    });

    thumbGrid.addEventListener("click", (e) => {
      const thumb = e.target.closest(".thumb");
      if (!thumb) return;
      const id = thumb.dataset.id;
      const p = state.photos.find(x => x.id === id);
      if (!p) return;

      if (e.target.classList.contains("x")){
        state.photos = state.photos.filter(x => x.id !== id);
        renderPhotos();
        saveToStorage();
        return;
      }

      const cap = prompt("Photo caption (optional):", p.caption || "");
      if (cap === null) return;
      p.caption = String(cap).trim();
      renderPhotos();
      saveToStorage();
    });

    btnClearPhotos.addEventListener("click", () => clearPhotos());

    // -------- Missing small functions from earlier blocks --------
    function renderTemplates(){
      templateGrid.innerHTML = "";
      for (const t of NOTE_TEMPLATES){
        const checked = !!state.meta.templates[t.id];
        const div = document.createElement("div");
        div.className = "checkRow";
        div.innerHTML = `
          <input type="checkbox" data-tpl="${t.id}" ${checked ? "checked":""} />
          <div class="t">
            <b>${escapeHtml(t.title)}</b>
            ${escapeHtml(t.text)}
          </div>
        `;
        templateGrid.appendChild(div);
      }
    }
    function applyTemplatesToNotes(){
      const chosen = NOTE_TEMPLATES.filter(t => state.meta.templates[t.id]).map(t => t.text);
      const manual = (notes.value || "").trim();
      const manualLines = manual ? manual.split("\n").map(s => s.trim()).filter(Boolean) : [];
      const all = [...manualLines];
      for (const line of chosen) if (!all.includes(line)) all.push(line);
      notes.value = all.join("\n");
      state.meta.notes = notes.value;
    }

    // -------- Boot --------
    function loadAndInit(){
      loadFromStorage();
      initDefaults();
      syncMetaToUI();

      renderTolerance();
      renderTemplates();
      renderPlan();
      renderPhotos();
      renderElevations(true);

      saveToStorage();
    }

    loadAndInit();
  </script>
</body>
</html>

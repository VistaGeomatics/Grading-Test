<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VistaGeomatics – Grading Check Report</title>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Montserrat:wght@400;700&display=swap" rel="stylesheet"/>

  <!-- PDF Export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

  <!-- PDF Upload Preview -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.js"></script>

  <style>
    :root{
      --vista-blue:#165f7d;
      --vista-blue-light:#2a7fa3;
      --vista-blue-dark:#0b3045;

      --pass-blue:#1f9cf0;  /* blue */
      --fail-red:#ef4444;   /* red */

      --bg-body:#eef3f9;
      --bg-card:#ffffff;
      --border-soft:#d6e2f0;

      --text-main:#101827;
      --text-muted:#5b6777;

      --ok:#15803d;
      --bad:#b91c1c;

      --shadow: 0 10px 30px rgba(2, 10, 20, 0.08);
      --radius: 16px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:"Inter", sans-serif;
      background: radial-gradient(circle at top, #f4fbff 0%, var(--bg-body) 55%, #e9f1fb 100%);
      color:var(--text-main);
    }
    .wrap{ max-width: 1180px; margin: 20px auto 60px; padding: 0 16px; }

    .topbar{
      background: linear-gradient(135deg, var(--vista-blue-dark), var(--vista-blue));
      color:#fff;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .topbar-inner{
      display:flex;
      align-items:center;
      gap:16px;
      padding: 16px 18px;
      flex-wrap:wrap;
    }
    .logo{
      width: 54px; height: 54px; border-radius: 12px;
      background: rgba(255,255,255,0.12);
      display:flex; align-items:center; justify-content:center;
      overflow:hidden; flex: 0 0 auto;
    }
    .logo img{ width: 100%; height: 100%; object-fit: contain; padding: 8px; }

    .brand{ flex:1 1 auto; min-width: 240px; }
    .brand .title{
      font-family:"Montserrat", sans-serif;
      font-weight:700; letter-spacing:0.5px;
      font-size: 18px; margin:0; line-height:1.2;
      text-transform: uppercase;
    }
    .brand .subtitle{ margin:4px 0 0; opacity:0.9; font-size: 13px; }

    .pill{
      display:flex; gap:10px; align-items:center;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.22);
      padding:10px 12px; border-radius: 999px;
      flex: 0 0 auto; white-space: nowrap;
    }
    .pill b{ font-weight:700; }
    .versionTag{
      background: rgba(255,255,255,0.14);
      border: 1px solid rgba(255,255,255,0.22);
      padding: 8px 12px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 800;
      opacity: 0.95;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 16px;
      margin-top: 16px;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns:1fr; }
      .pill{ width:100%; justify-content:space-between; }
      .versionTag{ width:100%; text-align:center; }
    }

    .card{
      background: var(--bg-card);
      border: 1px solid var(--border-soft);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card-h{
      padding: 14px 16px;
      border-bottom: 1px solid var(--border-soft);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      background: linear-gradient(180deg, #ffffff, #fbfdff);
      flex-wrap: wrap;
    }
    .card-h h2{ margin:0; font-size: 14px; letter-spacing:0.2px; }
    .card-b{ padding: 14px 16px 16px; }

    label{ display:block; font-size: 12px; color: var(--text-muted); margin-bottom: 6px; }

    input, select, textarea{
      width:100%;
      border: 1px solid var(--border-soft);
      border-radius: 12px;
      padding: 10px 10px;
      font-size: 14px;
      outline:none;
      background: rgba(255,255,255,0.55);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      color: var(--text-main);
    }
    textarea{ min-height: 92px; resize: vertical; }

    .formgrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 620px){ .formgrid{ grid-template-columns:1fr; } }

    .btnbar{ display:flex; gap: 10px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }
    .btn{
      appearance:none;
      border: 1px solid rgba(255,255,255,0);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight:700;
      cursor:pointer;
      transition: transform 0.05s ease, opacity 0.15s ease, background 0.15s ease;
      user-select:none;
      white-space: nowrap;
      font-family: "Inter", sans-serif;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ background: linear-gradient(135deg, var(--vista-blue), var(--vista-blue-light)); color:#fff; }
    .btn.ghost{ background: #f4f8fc; border: 1px solid var(--border-soft); color: var(--text-main); }
    .btn.danger{ background: #fff1f2; border: 1px solid #fecdd3; color: var(--bad); }
    .btn:disabled{ opacity:0.65; cursor:not-allowed; }

    .hint{ font-size: 12px; color: var(--text-muted); margin-top: 8px; line-height: 1.35; }

    table{
      width:100%;
      border-collapse: separate;
      border-spacing: 0;
      overflow:hidden;
      border: 1px solid var(--border-soft);
      border-radius: 14px;
    }
    thead th{
      text-align:left;
      font-size: 12px;
      color: var(--text-muted);
      padding: 10px 10px;
      background: #f6fafc;
      border-bottom: 1px solid var(--border-soft);
      white-space: nowrap;
    }
    tbody td{
      padding: 8px 10px;
      border-bottom: 1px solid var(--border-soft);
      vertical-align: middle;
      font-size: 14px;
    }
    tbody tr:last-child td{ border-bottom: none; }

    .mini{
      padding: 8px 8px;
      border-radius: 10px;
      font-size: 13px;
      background: rgba(255,255,255,0.55);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
    }

    .status{
      font-weight: 900;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      display:inline-block;
      border: 1px solid transparent;
      white-space: nowrap;
    }
    .status.ok{ color: var(--ok); background: #eaf7ee; border-color: #c7ecd2; }
    .status.bad{ color: var(--bad); background: #fff1f2; border-color: #fecdd3; }
    .status.na{ color: #475569; background: #eef2f7; border-color: #d6dee9; }

    .delta{ font-weight: 900; letter-spacing:0.1px; }
    .delta.ok{ color: var(--ok); }
    .delta.bad{ color: var(--bad); }
    .delta.na{ color:#475569; }

    .summary{
      display:flex; gap: 12px; flex-wrap:wrap;
      align-items:center; justify-content:space-between;
      margin-top: 10px;
      padding: 12px 12px;
      border: 1px dashed var(--border-soft);
      border-radius: 14px;
      background: #fbfdff;
    }
    .summary .k{ font-size: 12px; color: var(--text-muted); }
    .summary .v{ font-weight: 900; font-size: 14px; }

    /* Chips */
    .chips{ display:flex; gap:6px; flex-wrap:wrap; }
    .chip{
      border: 1px solid var(--border-soft);
      background: #fbfdff;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 900;
      color:#334155;
      cursor:pointer;
      user-select:none;
      transition: transform 0.05s ease, background 0.15s ease, border 0.15s ease;
    }
    .chip:active{ transform: translateY(1px); }
    .chip.on{
      border-color: rgba(31,156,240,0.55);
      background: rgba(31,156,240,0.10);
      color:#0b3045;
    }

    /* Notes checkboxes */
    .noteList{ display:grid; grid-template-columns: 1fr; gap:10px; margin-top:8px; }
    .noteItem{
      border: 1px solid var(--border-soft);
      border-radius: 14px;
      padding: 10px 12px;
      background: #fbfdff;
      display:flex;
      gap:10px;
      align-items:flex-start;
    }
    .noteItem input{ width:auto; margin-top:2px; }
    .noteItem b{ display:block; font-size: 13px; margin-bottom:2px; }
    .noteItem span{ display:block; font-size: 12px; color: var(--text-muted); line-height: 1.25; }

    /* Site photos thumbs */
    .photoRow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    .thumb{
      width: 170px;
      border-radius: 14px;
      border: 1px solid var(--border-soft);
      overflow:hidden;
      background:#fff;
      box-shadow: 0 6px 16px rgba(2,10,20,0.06);
      position:relative;
    }
    .thumb img{ width:100%; height:105px; object-fit:cover; display:block; }
    .thumb .cap{
      padding: 6px 8px;
      font-size: 11px;
      color:#334155;
      background:#fbfdff;
      border-top: 1px solid var(--border-soft);
      white-space: nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .thumb .x{
      position:absolute;
      top:6px;
      right:6px;
      background: rgba(0,0,0,0.55);
      color:#fff;
      border:none;
      border-radius: 999px;
      width: 26px;
      height: 26px;
      cursor:pointer;
      font-weight:900;
      line-height: 26px;
      text-align:center;
    }
    .thumb .photoChips{
      padding: 8px 8px 10px;
      border-top: 1px solid var(--border-soft);
      background:#fafcff;
    }
    .thumb .photoChips .chips{ gap:6px; }
    .thumb .photoChips .chip{ font-size:11px; padding:5px 8px; }

    /* Plot plan preview */
    .planPreview{
      border: 1px solid var(--border-soft);
      border-radius: 14px;
      overflow:hidden;
      background:#fff;
      box-shadow: 0 6px 16px rgba(2,10,20,0.06);
    }
    .planStage{
      position: relative;
      width: 100%;
      background:#fff;
      user-select: none;
      overflow: hidden;
      touch-action: manipulation;
    }
    .planStage img{ width:100%; height:auto; display:block; }
    .planOverlay{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
    }

    /* Point marker (small) */
    .mkAnchor{
      position:absolute;
      transform: translate(-50%, -50%);
      width: 12px;
      height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.85);
      background: rgba(22,95,125,0.25);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      box-shadow: 0 3px 8px rgba(2,10,20,0.12);
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:auto;
      cursor:pointer;
    }
    .mkAnchor span{
      font-size: 6px;
      font-weight: 900;
      color:#ffffff;
      line-height: 1;
    }
    .mkAnchor.sel{
      outline: 2px solid rgba(31,156,240,0.8);
      outline-offset: 2px;
    }

    /* Elevation tag sits beside number (collision-adjusted) */
    .mkElev{
      position:absolute;
      transform: translate(0, -50%);
      padding: 1px 3px;
      border-radius: 7px;
      border: 1px solid rgba(255,255,255,0.85);
      background: rgba(22,95,125,0.14);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      box-shadow: 0 3px 8px rgba(2,10,20,0.10);
      pointer-events:none;
      white-space: nowrap;
      text-align:center;
    }
    .mkElev .el{
      font-size: 6px;
      font-weight: 900;
      line-height: 1.05;
    }
    .mkElev .el.pass{ color: var(--pass-blue); }
    .mkElev .el.fail{ color: var(--fail-red); }
    .mkElev .el.na{ color: rgba(255,255,255,0.92); }

    .planMeta{
      padding: 10px 12px;
      border-top: 1px solid var(--border-soft);
      background:#fafcff;
      font-size:12px;
      color:#334155;
      display:flex;
      gap:10px;
      justify-content:space-between;
      align-items:center;
      flex-wrap:wrap;
    }

    /* Slope label small red */
    .slopeLabel{
      font-family:"Inter", sans-serif;
      font-weight: 900;
      font-size: 7px;
      fill: rgba(239,68,68,0.98);
      paint-order: stroke;
      stroke: rgba(0,0,0,0.55);
      stroke-width: 2px;
      stroke-linejoin: round;
    }

    .bottomActions{
      margin-top: 10px;
      display:flex;
      gap:10px;
      justify-content:flex-end;
      flex-wrap:wrap;
      padding: 8px 0 0;
    }

    /* ---------- Entry Panel Overlay ---------- */
    .overlay{
      position: fixed;
      inset: 0;
      background: rgba(2,10,20,0.25);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 9999;
    }
    .panel{
      width: min(760px, 100%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.35);
      background: rgba(255,255,255,0.35); /* transparent so crews can read plan */
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 18px 60px rgba(2,10,20,0.35);
      overflow: hidden;
    }
    .panelH{
      padding: 14px 16px;
      background: linear-gradient(135deg, rgba(11,48,69,0.10), rgba(22,95,125,0.10));
      border-bottom: 1px solid rgba(214,226,240,0.75);
      display:flex;
      gap:12px;
      justify-content:space-between;
      align-items:center;
      flex-wrap: wrap;
    }
    .panelH h3{
      margin:0;
      font-size: 13px;
      letter-spacing:0.2px;
      color:#0b3045;
      font-family:"Montserrat", sans-serif;
      font-weight:700;
      text-transform: uppercase;
    }
    .panelB{ padding: 14px 16px 16px; }
    .panelGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 560px){ .panelGrid{ grid-template-columns: 1fr; } }
    .panelActions{
      padding: 12px 16px 16px;
      border-top: 1px solid rgba(214,226,240,0.75);
      display:flex;
      gap:10px;
      justify-content:flex-end;
      flex-wrap: wrap;
      background: rgba(255,255,255,0.40);
    }

    .toast{
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(2,10,20,0.75);
      color: #fff;
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 12px;
      z-index: 10000;
      display:none;
      max-width: calc(100% - 40px);
      text-align:center;
    }

    /* Export host (hidden) */
    #exportHost{
      position: fixed;
      left: -99999px;
      top: 0;
      width: 816px;
      background: #fff;
      color:#101827;
    }
    .report{ padding: 18px 18px 22px; font-family:"Inter", sans-serif; }
    .reportHeader{
      display:flex; gap:12px; align-items:center;
      border-bottom: 2px solid #e5edf7;
      padding-bottom: 12px; margin-bottom: 12px;
    }
    .reportLogo{
      width: 52px; height: 52px; border-radius: 12px;
      border: 1px solid #e5edf7;
      display:flex; align-items:center; justify-content:center;
      overflow:hidden; background:#fff;
    }
    .reportLogo img{ width:100%; height:100%; object-fit:contain; padding:8px; }
    .reportTitle{
      font-family:"Montserrat", sans-serif;
      font-weight:700; letter-spacing:0.5px;
      margin:0; font-size: 16px; color:#0b3045;
      text-transform: uppercase;
    }
    .reportSub{ margin:4px 0 0; font-size: 12px; color:#475569; }

    .reportMeta{
      display:grid; grid-template-columns: 1fr 1fr;
      gap: 8px 12px; margin: 10px 0 14px;
      font-size: 12px; color:#334155;
    }
    .reportMeta b{ color:#0b3045; }

    .reportSectionTitle{
      font-family:"Montserrat", sans-serif;
      font-weight:700; font-size: 13px;
      color:#0b3045; margin: 14px 0 8px;
      text-transform: uppercase;
    }

    .reportTable{
      width:100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    .reportTable th, .reportTable td{
      border: 1px solid #d6dee9;
      padding: 6px 6px;
      vertical-align: top;
    }
    .reportTable th{
      background:#f6fafc;
      color:#334155;
      font-weight:700;
      text-align:left;
      white-space: nowrap;
    }

    .pillSmall{
      display:inline-block;
      padding: 3px 8px;
      border-radius: 999px;
      font-size: 10px;
      font-weight: 900;
      border: 1px solid #d6dee9;
      background:#eef2f7;
      color:#334155;
      white-space:nowrap;
    }
    .pillSmall.ok{ background:#eaf7ee; border-color:#c7ecd2; color:#15803d; }
    .pillSmall.bad{ background:#fff1f2; border-color:#fecdd3; color:#b91c1c; }

    .pageBreak{ page-break-before: always; }

    .planPrintWrap{
      border:1px solid #d6dee9;
      border-radius:12px;
      overflow:hidden;
    }
    .planPrintStage{ position: relative; overflow:hidden; }
    .planPrintStage img{ width:100%; height:auto; display:block; }
    .planPrintOverlay{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
    }
    .mkAnchorPrint{
      position:absolute;
      transform: translate(-50%, -50%);
      width: 12px; height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.85);
      background: rgba(22,95,125,0.25);
      box-shadow: 0 3px 8px rgba(2,10,20,0.12);
      display:flex; align-items:center; justify-content:center;
    }
    .mkAnchorPrint span{
      font-size: 6px;
      font-weight: 900;
      color:#ffffff;
      line-height: 1;
    }
    .mkElevPrint{
      position:absolute;
      transform: translate(0, -50%);
      padding: 1px 3px;
      border-radius: 7px;
      border: 1px solid rgba(255,255,255,0.85);
      background: rgba(22,95,125,0.14);
      box-shadow: 0 3px 8px rgba(2,10,20,0.10);
      white-space: nowrap;
      text-align:center;
    }
    .mkElevPrint .el{
      font-size: 6px;
      font-weight: 900;
      line-height: 1.05;
    }
    .mkElevPrint .el.pass{ color: var(--pass-blue); }
    .mkElevPrint .el.fail{ color: var(--fail-red); }
    .mkElevPrint .el.na{ color: rgba(255,255,255,0.92); }

    .photoGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      border:1px solid #d6dee9;
      border-radius:12px;
      padding: 10px;
      background:#fbfdff;
    }
    .photoCell{
      border:1px solid #d6dee9;
      border-radius:12px;
      overflow:hidden;
      background:#fff;
    }
    .photoCell img{
      width:100%;
      height: 220px;
      object-fit: cover;
      display:block;
    }
    .photoCell .pCap{
      padding: 6px 8px;
      font-size: 10px;
      color:#334155;
      background:#f6fafc;
      border-top:1px solid #d6dee9;
      white-space: nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="topbar-inner">
        <div class="logo" title="Vista Geomatics">
          <img src="vista-geomatics.png" alt="Vista Geomatics Logo" />
        </div>

        <div class="brand">
          <p class="title">Grading Check Report</p>
          <p class="subtitle">Plot Plan Markups, Setups & Shots, Differences, Slopes, Photos</p>
        </div>

        <div class="pill">
          <span><b>Area</b></span>
          <select id="areaSelect" style="width:auto; background: rgba(255,255,255,0.95); color:#0b3045; border:none; border-radius:999px; padding:8px 10px;">
            <option value="calgary">Calgary</option>
            <option value="chestermere">Chestermere</option>
            <option value="airdrie">Airdrie</option>
          </select>
        </div>

        <div class="pill">
          <span><b>Tolerance</b></span>
          <span id="tolLabel">±15 cm</span>
        </div>

        <div class="versionTag">v1.6</div>
      </div>
    </div>

    <div class="grid">

      <!-- Job Details -->
      <div class="card">
        <div class="card-h">
          <h2>Job Details</h2>
          <div class="btnbar">
            <button class="btn ghost" id="btnSave" type="button">Save</button>
            <button class="btn danger" id="btnResetTop" type="button">Clear</button>
          </div>
        </div>
        <div class="card-b">
          <div class="formgrid">
            <div>
              <label>Job Number</label>
              <input id="jobNo" placeholder="e.g., 25-0123" autocomplete="off" />
            </div>
            <div>
              <label>Date</label>
              <input id="jobDate" type="date" />
            </div>
            <div>
              <label>Community / Subdivision</label>
              <input id="community" placeholder="e.g., Cornerstone" autocomplete="off" />
            </div>
            <div>
              <label>Address</label>
              <input id="address" placeholder="e.g., 2053–2055 Cornerstone Blvd NE" autocomplete="off" />
            </div>
            <div>
              <label>Lot / Block / Plan</label>
              <input id="lotBlockPlan" placeholder="e.g., Lot 12, Block 3, Plan ____" autocomplete="off" />
            </div>
            <div>
              <label>Crew Chief</label>
              <input id="crewChief" placeholder="Name" autocomplete="off" />
            </div>
          </div>

          <div class="summary" style="margin-top:14px;">
            <div><div class="k">Shots</div><div class="v" id="sumShots">0</div></div>
            <div><div class="k">Fails</div><div class="v" id="sumFails">0</div></div>
            <div><div class="k">Worst Δ (cm)</div><div class="v" id="sumWorst">—</div></div>
          </div>

          <div class="hint">
            Storage-limit issue fixed by saving Plot Plan + Photos in IndexedDB (not localStorage).
          </div>
        </div>
      </div>

      <!-- Office Summary -->
      <div class="card">
        <div class="card-h">
          <h2>Office Summary</h2>
          <div class="btnbar">
            <button class="btn ghost" id="btnGenSummary" type="button">Generate</button>
            <button class="btn primary" id="btnCopySummary" type="button">Copy</button>
          </div>
        </div>
        <div class="card-b">
          <label>Auto-generated summary for office & drafters</label>
          <textarea id="officeSummary" placeholder="Click Generate to build a consistent summary..."></textarea>
          <div class="hint">
            Includes tolerance, setup count, out-of-tolerance shots, slopes, site notes, and photo captions.
          </div>
        </div>
      </div>

      <!-- Notes Section -->
      <div class="card" style="grid-column: 1 / -1;">
        <div class="card-h">
          <h2>Field Notes (Consistent Checkboxes)</h2>
        </div>
        <div class="card-b">
          <div class="noteList" id="noteList"></div>
        </div>
      </div>

      <!-- Setups + Shots -->
      <div class="card" style="grid-column: 1 / -1;">
        <div class="card-h">
          <h2>Level Setups & Shots (HI-based IFS/Elev)</h2>
          <div class="btnbar">
            <button class="btn ghost" id="btnAddSetup" type="button">Add Setup</button>
            <button class="btn ghost" id="btnAddShot" type="button">Add Shot</button>
            <button class="btn danger" id="btnRemoveSelectedShots" type="button">Remove Selected</button>
          </div>
        </div>
        <div class="card-b">
          <div class="hint" style="margin-top:0;">
            Works both ways: enter <b>HI + Elev → IFS auto</b>, or <b>HI + IFS → Elev auto</b>. Each shot uses the HI from its setup.
          </div>

          <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px;">
            <div style="min-width:260px; flex: 0 0 auto;">
              <label>Active Setup</label>
              <select id="activeSetup"></select>
            </div>
            <div class="hint" style="margin-top:18px;">
              Plot plan clicks add shots to the active setup.
            </div>
          </div>

          <div style="margin-top:12px; overflow:auto;">
            <table>
              <thead>
                <tr>
                  <th style="width:44px;">Sel</th>
                  <th style="min-width:120px;">Type</th>
                  <th style="min-width:140px;">STA / Point</th>
                  <th style="min-width:120px;">BS</th>
                  <th style="min-width:120px;">HI</th>
                  <th style="min-width:120px;">FS</th>
                  <th style="min-width:120px;">IFS</th>
                  <th style="min-width:120px;">ELEV</th>
                  <th style="min-width:140px;">Designed Elev</th>
                  <th style="min-width:110px;">Δ (cm)</th>
                  <th style="min-width:110px;">Status</th>
                  <th style="min-width:340px;">Point Notes</th>
                </tr>
              </thead>
              <tbody id="shotsBody"></tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- Site Photos -->
      <div class="card" style="grid-column: 1 / -1;">
        <div class="card-h">
          <h2>Site Photos (Thumbnails + Export)</h2>
          <div class="btnbar">
            <label class="btn ghost" style="cursor:pointer;">
              Upload Photos
              <input id="photoInput" type="file" accept="image/*" multiple style="display:none;">
            </label>
            <button class="btn danger" id="btnClearPhotos" type="button">Clear Photos</button>
          </div>
        </div>
        <div class="card-b">
          <div class="hint" style="margin-top:0;">
            Photos save to IndexedDB, export includes larger images 4 per page.
          </div>
          <div class="photoRow" id="photoRow"></div>
        </div>
      </div>

      <!-- Plot plan -->
      <div class="card" style="grid-column:1/-1;">
        <div class="card-h">
          <h2>Marked Up Plot Plan (Image or PDF)</h2>
          <div class="btnbar">
            <button class="btn ghost" id="btnSlopeMode" type="button">Slope Mode: OFF</button>
            <label class="btn ghost" style="cursor:pointer;">
              Upload Plot Plan
              <input id="planInput" type="file" accept="image/*,application/pdf" style="display:none;">
            </label>
            <button class="btn danger" id="btnClearPlan" type="button">Remove</button>
            <button class="btn ghost" id="btnClearMarkers" type="button">Clear Points</button>
          </div>
        </div>
        <div class="card-b">
          <div class="hint" id="planHint" style="margin-top:0;">
            Tap the plan to add a shot: point label drops at your tap, elevation displays beside it (blue pass, red fail).
          </div>

          <div id="planEmpty" style="margin-top:12px; padding:14px; border:1px dashed var(--border-soft); border-radius:14px; background:#fbfdff; color:var(--text-muted);">
            No plot plan attached yet.
          </div>

          <div id="planWrap" style="margin-top:12px; display:none;">
            <div class="planPreview">
              <div class="planStage" id="planStage" title="Tap on the plan to add a point">
                <img id="planImg" alt="Marked up plot plan preview" />
                <svg class="planOverlay" id="planOverlay" viewBox="0 0 1000 1000" preserveAspectRatio="none"></svg>
              </div>
              <div class="planMeta">
                <div>
                  <b id="planName">—</b>
                  <div id="planType" style="opacity:0.85; margin-top:2px;"></div>
                </div>
                <div class="hint" style="margin:0;">
                  Tap a point number to edit. In Slope Mode, tap Point A then Point B.
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Slopes -->
      <div class="card" style="grid-column: 1 / -1;">
        <div class="card-h">
          <h2>Slope Calculator (Between Points)</h2>
          <div class="btnbar">
            <button class="btn ghost" id="btnAddSlope" type="button">Add Slope Row</button>
            <button class="btn danger" id="btnRemoveSlopeSelected" type="button">Remove Selected</button>
          </div>
        </div>
        <div class="card-b">
          <div class="hint" style="margin-top:0;">
            Slope% = |Δ elev (cm)| ÷ run (m). Arrow always points downhill.
          </div>

          <div style="margin-top:12px; overflow:auto;">
            <table>
              <thead>
                <tr>
                  <th style="width:44px;">Sel</th>
                  <th style="min-width:220px;">Segment</th>
                  <th style="min-width:170px;">From</th>
                  <th style="min-width:170px;">To</th>
                  <th style="min-width:140px;">Distance (m)</th>
                  <th style="min-width:140px;">Downhill Slope %</th>
                </tr>
              </thead>
              <tbody id="slopeBody"></tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- Bottom Buttons -->
      <div class="card" style="grid-column: 1 / -1;">
        <div class="card-b">
          <div class="bottomActions">
            <button class="btn ghost" id="btnResetBottom" type="button">Clear Form</button>
            <button class="btn primary" id="btnPDF" type="button">Download PDF</button>
            <button class="btn primary" id="btnShare" type="button">Share PDF</button>
          </div>
          <div class="hint" style="text-align:right;">
            Export includes separate pages: Check Report, Plot Plan, Tables, Photos.
          </div>
        </div>
      </div>

    </div>
  </div>

  <!-- Entry Panel Overlay -->
  <div class="overlay" id="overlay">
    <div class="panel" id="panel">
      <div class="panelH">
        <h3 id="panelTitle">Entry</h3>
        <div class="btnbar" style="justify-content:flex-end;">
          <button class="btn ghost" id="btnPanelClose" type="button">Close</button>
        </div>
      </div>
      <div class="panelB" id="panelBody"></div>
      <div class="panelActions" id="panelActions"></div>
    </div>
  </div>

  <div class="toast" id="toast">Saved</div>
  <div id="exportHost" aria-hidden="true"></div>

  <script>
    // ---------------- PDF.js worker ----------------
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.js";
    }

    // ---------------- IndexedDB (fixes storage limit) ----------------
    const DB_NAME = "vista_grading_db";
    const DB_VER = 1;
    const STORE_FILES = "files";

    function openDB(){
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VER);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(STORE_FILES)) db.createObjectStore(STORE_FILES);
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbPut(key, value){
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_FILES, "readwrite");
        tx.objectStore(STORE_FILES).put(value, key);
        tx.oncomplete = () => { db.close(); resolve(); };
        tx.onerror = () => { db.close(); reject(tx.error); };
      });
    }

    async function idbGet(key){
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_FILES, "readonly");
        const req = tx.objectStore(STORE_FILES).get(key);
        req.onsuccess = () => { db.close(); resolve(req.result ?? null); };
        req.onerror = () => { db.close(); reject(req.error); };
      });
    }

    async function idbDel(key){
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_FILES, "readwrite");
        tx.objectStore(STORE_FILES).delete(key);
        tx.oncomplete = () => { db.close(); resolve(); };
        tx.onerror = () => { db.close(); reject(tx.error); };
      });
    }

    async function idbClearAll(){
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_FILES, "readwrite");
        tx.objectStore(STORE_FILES).clear();
        tx.oncomplete = () => { db.close(); resolve(); };
        tx.onerror = () => { db.close(); reject(tx.error); };
      });
    }

    function blobToObjectURL(blob){
      if (!blob) return null;
      return URL.createObjectURL(blob);
    }

    async function dataUrlToBlob(dataUrl){
      const res = await fetch(dataUrl);
      return await res.blob();
    }

    // ---------------- App State ----------------
    const STORAGE_KEY = "vista_grading_check_v16_meta";
    const tolByAreaCm = { calgary: 15, chestermere: 15, airdrie: 10 };

    const POINT_NOTE_CHIPS = ["OK","Low","High","Regrade","Verify","TC","Top of Concrete","Hold","Builder on site"];
    const PHOTO_CAPTION_CHIPS = ["Obstruction","Snow/Ice","Soft/Wet","Builder Activity","Out of Tolerance","Other"];

    const NOTE_CHECKS = [
      { title:"Access / Site Condition", text:"Site accessible, no major obstructions impacting shots." },
      { title:"Access / Site Condition", text:"Obstructions present on site, some shots limited, see photos and point notes." },
      { title:"Weather / Surface", text:"Snow/ice present, measurements taken with caution and limited surface visibility in areas." },
      { title:"Weather / Surface", text:"Soft/wet soil conditions observed, expect potential settlement/adjustment after compaction." },
      { title:"Construction Activity", text:"Builder equipment/materials on site during survey, access constraints noted." },
      { title:"Follow-up", text:"Recheck required after regrade/adjustment, see out-of-tolerance items." },
      { title:"Hold", text:"Hold pending builder correction/confirmation, office to review before drafting." }
    ];

    const state = {
      meta: {
        area:"calgary", jobNo:"", jobDate:"", community:"", address:"", lotBlockPlan:"", crewChief:"",
        officeSummary:"",
        nextPoint: 1,
        activeSetupId: ""
      },
      noteChecks: [],

      // Plot plan is stored in IndexedDB. meta only stores keys + kind.
      plan: null, // { key, name, kind } (blob stored in idb as image/jpeg)
      planObjectURL: null, // runtime URL

      // site photos stored in IndexedDB, each photo stores key
      sitePhotos: [], // {id, name, key, captionTag}

      // plan markers tied to shots
      markers: [], // {id, xPct, yPct, labelXPct, labelYPct, pointLabel, shotId}

      setups: [
        // setup: { id, name, bs, hi, fs, elev, shots:[ {id, label, ifs, elev, designElev, note} ] }
      ],

      slopeRows: [], // {id, segment, fromLabel, toLabel, distanceM}
      ui: { slopeMode:false, slopePick:null }
    };

    // ---------------- Helpers ----------------
    function uid(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }

    function todayISO(){
      const d = new Date();
      return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`;
    }

    function safeName(s){
      return String(s ?? "").trim().replace(/[\\/:*?"<>|]+/g,"").replace(/\s+/g," ").replaceAll(" ","_").slice(0,80) || "Grading_Check";
    }

    function defaultFileName(ext){
      const job = safeName(state.meta.jobNo || "Job");
      const crew = safeName(state.meta.crewChief || "Crew");
      return `${job}_${crew}_${todayISO()}.${ext}`;
    }

    function escapeHtml(s){
      return String(s ?? "")
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
        .replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }

    function parseNumber(v){
      const s = String(v ?? "").trim();
      if (!s) return null;
      const n = Number(s.replace(",", "."));
      return Number.isFinite(n) ? n : null;
    }

    // Elevations are treated as "cm-style" integers like 9221, 9267 (differences are in cm)
    function calcDeltaCm(field, design){
      const f = parseNumber(field);
      const d = parseNumber(design);
      if (!Number.isFinite(f) || !Number.isFinite(d)) return null;
      return f - d; // cm
    }

    function passFail(deltaCmVal, tolCm){
      if (!Number.isFinite(deltaCmVal)) return "N/A";
      return Math.abs(deltaCmVal) <= tolCm ? "PASS" : "FAIL";
    }

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    function toast(msg){
      const t = document.getElementById("toast");
      t.textContent = msg;
      t.style.display = "block";
      clearTimeout(toast._tm);
      toast._tm = setTimeout(() => t.style.display = "none", 1200);
    }

    // HI math (works both ways)
    // If HI and Elev entered -> IFS = HI - Elev
    // If HI and IFS entered -> Elev = HI - IFS
    function computeIFS(hi, elev){
      const H = parseNumber(hi), E = parseNumber(elev);
      if (!Number.isFinite(H) || !Number.isFinite(E)) return null;
      return H - E;
    }
    function computeElev(hi, ifs){
      const H = parseNumber(hi), I = parseNumber(ifs);
      if (!Number.isFinite(H) || !Number.isFinite(I)) return null;
      return H - I;
    }

    // Optional: BS + Elev -> HI, HI - BS -> Elev
    function computeHIFromBS(bs, elev){
      const B = parseNumber(bs), E = parseNumber(elev);
      if (!Number.isFinite(B) || !Number.isFinite(E)) return null;
      return B + E;
    }
    function computeElevFromBS(hi, bs){
      const H = parseNumber(hi), B = parseNumber(bs);
      if (!Number.isFinite(H) || !Number.isFinite(B)) return null;
      return H - B;
    }

    // ---------------- Elements ----------------
    const areaSelect = document.getElementById("areaSelect");
    const tolLabel = document.getElementById("tolLabel");

    const jobNo = document.getElementById("jobNo");
    const jobDate = document.getElementById("jobDate");
    const community = document.getElementById("community");
    const address = document.getElementById("address");
    const lotBlockPlan = document.getElementById("lotBlockPlan");
    const crewChief = document.getElementById("crewChief");

    const sumShots = document.getElementById("sumShots");
    const sumFails = document.getElementById("sumFails");
    const sumWorst = document.getElementById("sumWorst");

    const btnSave = document.getElementById("btnSave");
    const btnResetTop = document.getElementById("btnResetTop");
    const btnResetBottom = document.getElementById("btnResetBottom");

    const btnPDF = document.getElementById("btnPDF");
    const btnShare = document.getElementById("btnShare");

    const officeSummary = document.getElementById("officeSummary");
    const btnGenSummary = document.getElementById("btnGenSummary");
    const btnCopySummary = document.getElementById("btnCopySummary");

    const noteList = document.getElementById("noteList");

    const activeSetup = document.getElementById("activeSetup");
    const shotsBody = document.getElementById("shotsBody");
    const btnAddSetup = document.getElementById("btnAddSetup");
    const btnAddShot = document.getElementById("btnAddShot");
    const btnRemoveSelectedShots = document.getElementById("btnRemoveSelectedShots");

    const photoInput = document.getElementById("photoInput");
    const btnClearPhotos = document.getElementById("btnClearPhotos");
    const photoRow = document.getElementById("photoRow");

    const planInput = document.getElementById("planInput");
    const btnClearPlan = document.getElementById("btnClearPlan");
    const btnClearMarkers = document.getElementById("btnClearMarkers");
    const planWrap = document.getElementById("planWrap");
    const planEmpty = document.getElementById("planEmpty");
    const planStage = document.getElementById("planStage");
    const planOverlay = document.getElementById("planOverlay");
    const planImg = document.getElementById("planImg");
    const planName = document.getElementById("planName");
    const planType = document.getElementById("planType");
    const btnSlopeMode = document.getElementById("btnSlopeMode");
    const planHint = document.getElementById("planHint");

    const slopeBody = document.getElementById("slopeBody");
    const btnAddSlope = document.getElementById("btnAddSlope");
    const btnRemoveSlopeSelected = document.getElementById("btnRemoveSlopeSelected");

    const exportHost = document.getElementById("exportHost");

    // panel
    const overlay = document.getElementById("overlay");
    const panelTitle = document.getElementById("panelTitle");
    const panelBody = document.getElementById("panelBody");
    const panelActions = document.getElementById("panelActions");
    const btnPanelClose = document.getElementById("btnPanelClose");

    // ---------------- Persistence (meta only in localStorage) ----------------
    function saveMeta(showToast=false){
      try{
        const payload = {
          meta: state.meta,
          noteChecks: state.noteChecks,
          plan: state.plan,
          sitePhotos: state.sitePhotos,
          markers: state.markers,
          setups: state.setups,
          slopeRows: state.slopeRows,
          ui: state.ui
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        if (showToast) toast("Saved");
      }catch(e){
        // This should rarely happen now (no big base64 strings in localStorage)
        alert("Save failed (storage). If this persists, clear browser site data for this page.");
      }
    }

    function loadMeta(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        const p = JSON.parse(raw);
        if (!p || typeof p !== "object") return false;

        state.meta = Object.assign(state.meta, p.meta || {});
        state.noteChecks = Array.isArray(p.noteChecks) ? p.noteChecks : [];
        state.plan = p.plan || null;
        state.sitePhotos = Array.isArray(p.sitePhotos) ? p.sitePhotos : [];
        state.markers = Array.isArray(p.markers) ? p.markers : [];
        state.setups = Array.isArray(p.setups) ? p.setups : [];
        state.slopeRows = Array.isArray(p.slopeRows) ? p.slopeRows : [];
        state.ui = Object.assign(state.ui, p.ui || {});
        return true;
      }catch(e){ return false; }
    }

    // ---------------- UI Rendering ----------------
    function renderTolerance(){
      const tol = tolByAreaCm[state.meta.area] ?? 15;
      tolLabel.textContent = `±${tol} cm`;
    }

    function renderNotes(){
      noteList.innerHTML = "";
      if (!Array.isArray(state.noteChecks) || state.noteChecks.length !== NOTE_CHECKS.length){
        state.noteChecks = NOTE_CHECKS.map(() => false);
      }
      NOTE_CHECKS.forEach((n, idx) => {
        const row = document.createElement("div");
        row.className = "noteItem";
        row.innerHTML = `
          <input type="checkbox" data-note-idx="${idx}" ${state.noteChecks[idx] ? "checked" : ""} />
          <div>
            <b>${escapeHtml(n.title)}</b>
            <span>${escapeHtml(n.text)}</span>
          </div>
        `;
        noteList.appendChild(row);
      });
    }

    function shotsFlat(){
      const out = [];
      for (const s of state.setups){
        out.push({ type:"setup", setupId:s.id, rowId:s.id });
        for (const sh of (s.shots || [])){
          out.push({ type:"shot", setupId:s.id, rowId:sh.id });
        }
      }
      return out;
    }

    function calcShotStatus(setup, shot){
      const tol = tolByAreaCm[state.meta.area] ?? 15;
      const delta = calcDeltaCm(shot.elev, shot.designElev);
      const status = passFail(delta, tol);
      return { delta, status };
    }

    function renderSummary(){
      const tol = tolByAreaCm[state.meta.area] ?? 15;
      let shots = 0, fails = 0;
      let worstAbs = null, worstSigned = null;

      for (const setup of state.setups){
        for (const sh of (setup.shots || [])){
          const delta = calcDeltaCm(sh.elev, sh.designElev);
          if (!Number.isFinite(delta)) continue;
          shots++;
          if (Math.abs(delta) > tol) fails++;
          const abs = Math.abs(delta);
          if (worstAbs === null || abs > worstAbs){
            worstAbs = abs;
            worstSigned = delta;
          }
        }
      }
      sumShots.textContent = String(shots);
      sumFails.textContent = String(fails);
      sumWorst.textContent = worstSigned === null ? "—" : String(Math.round(worstSigned * 10) / 10);
    }

    function renderActiveSetupSelect(){
      activeSetup.innerHTML = "";
      if (!state.setups.length){
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No setups, add one";
        activeSetup.appendChild(opt);
        state.meta.activeSetupId = "";
        return;
      }

      for (const s of state.setups){
        const opt = document.createElement("option");
        opt.value = s.id;
        opt.textContent = s.name || "Setup";
        activeSetup.appendChild(opt);
      }

      if (!state.meta.activeSetupId || !state.setups.find(s => s.id === state.meta.activeSetupId)){
        state.meta.activeSetupId = state.setups[0].id;
      }
      activeSetup.value = state.meta.activeSetupId;
    }

    function fmt(n, d=0){
      return Number.isFinite(n) ? n.toFixed(d) : "";
    }

    function pointNoteChips(selected, dataRow){
      return POINT_NOTE_CHIPS.map(c => {
        const on = (selected||"") === c;
        return `<span class="chip ${on ? "on":""}" data-chip="${escapeHtml(c)}" data-row="${dataRow}">${escapeHtml(c)}</span>`;
      }).join("");
    }

    function renderShotsTable(){
      shotsBody.innerHTML = "";

      for (const setup of state.setups){
        // setup row
        const trS = document.createElement("tr");
        trS.dataset.type = "setup";
        trS.dataset.setupId = setup.id;

        const hi = parseNumber(setup.hi);
        const bs = parseNumber(setup.bs);
        const elev = parseNumber(setup.elev);

        // if HI blank but BS+Elev exists -> compute HI
        if (!Number.isFinite(hi)){
          const autoHI = computeHIFromBS(setup.bs, setup.elev);
          if (Number.isFinite(autoHI)) setup.hi = String(autoHI);
        }
        // if Elev blank but HI+BS exists -> compute Elev
        if (!Number.isFinite(elev)){
          const autoElev = computeElevFromBS(setup.hi, setup.bs);
          if (Number.isFinite(autoElev)) setup.elev = String(autoElev);
        }

        trS.innerHTML = `
          <td><input type="checkbox" class="selRow" data-kind="setup" data-setup="${setup.id}" data-id="${setup.id}"></td>
          <td><span class="status na">SETUP</span></td>
          <td><input class="mini" data-kind="setup" data-k="name" data-setup="${setup.id}" value="${escapeHtml(setup.name||"")}" placeholder="e.g., RMOW, TP, LMOW"/></td>
          <td><input class="mini" data-kind="setup" data-k="bs" data-setup="${setup.id}" type="number" step="any" inputmode="decimal" value="${escapeHtml(setup.bs||"")}" placeholder="BS"/></td>
          <td><input class="mini" data-kind="setup" data-k="hi" data-setup="${setup.id}" type="number" step="any" inputmode="decimal" value="${escapeHtml(setup.hi||"")}" placeholder="HI"/></td>
          <td><input class="mini" data-kind="setup" data-k="fs" data-setup="${setup.id}" type="number" step="any" inputmode="decimal" value="${escapeHtml(setup.fs||"")}" placeholder="FS"/></td>
          <td><input class="mini" data-kind="setup" data-k="ifs" data-setup="${setup.id}" type="number" step="any" inputmode="decimal" value="${escapeHtml(setup.ifs||"")}" placeholder="IFS"/></td>
          <td><input class="mini" data-kind="setup" data-k="elev" data-setup="${setup.id}" type="number" step="any" inputmode="decimal" value="${escapeHtml(setup.elev||"")}" placeholder="ELEV"/></td>
          <td></td>
          <td><span class="delta na">—</span></td>
          <td><span class="status na">—</span></td>
          <td><div class="hint" style="margin:0;">BS/HI/IFS/ELEV auto-calc where possible</div></td>
        `;
        shotsBody.appendChild(trS);

        // shot rows
        for (const sh of (setup.shots || [])){
          // enforce HI-based calc:
          const H = parseNumber(setup.hi);
          const I = parseNumber(sh.ifs);
          const E = parseNumber(sh.elev);

          // if HI & Elev -> compute IFS
          if (Number.isFinite(H) && Number.isFinite(E) && !Number.isFinite(I)){
            const autoI = computeIFS(H, E);
            if (Number.isFinite(autoI)) sh.ifs = String(autoI);
          }
          // if HI & IFS -> compute Elev
          if (Number.isFinite(H) && Number.isFinite(I) && !Number.isFinite(E)){
            const autoE = computeElev(H, I);
            if (Number.isFinite(autoE)) sh.elev = String(autoE);
          }

          const { delta, status } = calcShotStatus(setup, sh);
          const deltaClass = status==="PASS" ? "ok" : (status==="FAIL" ? "bad" : "na");
          const statusClass = status==="PASS" ? "ok" : (status==="FAIL" ? "bad" : "na");

          const tr = document.createElement("tr");
          tr.dataset.type = "shot";
          tr.dataset.setupId = setup.id;
          tr.dataset.shotId = sh.id;

          tr.innerHTML = `
            <td><input type="checkbox" class="selRow" data-kind="shot" data-setup="${setup.id}" data-id="${sh.id}"></td>
            <td><span class="status na">SHOT</span></td>
            <td><input class="mini" data-kind="shot" data-k="label" data-setup="${setup.id}" data-id="${sh.id}" value="${escapeHtml(sh.label||"")}" placeholder="Point (auto)"/></td>
            <td></td>
            <td><span class="hint" style="margin:0; font-weight:900; color:#0b3045;">${escapeHtml(setup.hi||"")}</span></td>
            <td></td>
            <td><input class="mini" data-kind="shot" data-k="ifs" data-setup="${setup.id}" data-id="${sh.id}" type="number" step="any" inputmode="decimal" value="${escapeHtml(sh.ifs||"")}" placeholder="IFS"/></td>
            <td><input class="mini" data-kind="shot" data-k="elev" data-setup="${setup.id}" data-id="${sh.id}" type="number" step="any" inputmode="decimal" value="${escapeHtml(sh.elev||"")}" placeholder="ELEV"/></td>
            <td><input class="mini" data-kind="shot" data-k="designElev" data-setup="${setup.id}" data-id="${sh.id}" type="number" step="any" inputmode="decimal" value="${escapeHtml(sh.designElev||"")}" placeholder="Designed"/></td>
            <td><span class="delta ${deltaClass}">${Number.isFinite(delta)? (Math.round(delta*10)/10) : "—"}</span></td>
            <td><span class="status ${statusClass}">${status}</span></td>
            <td>
              <div class="chips" data-chip-row="${sh.id}">
                ${pointNoteChips(sh.note||"", sh.id)}
                <input class="mini" style="margin-top:6px;" data-kind="shot" data-k="note" data-setup="${setup.id}" data-id="${sh.id}" value="${escapeHtml(sh.note||"")}" placeholder="Custom note (optional)" />
              </div>
            </td>
          `;
          shotsBody.appendChild(tr);
        }
      }

      renderSummary();
      renderPlan(); // sync marker colors/elev display
      saveMeta();
    }

    // ---------------- Auto point numbering ----------------
    function getMaxNumericPoint(){
      let maxN = 0;
      for (const setup of state.setups){
        for (const sh of (setup.shots || [])){
          const s = String(sh.label||"").trim();
          if (/^\d+$/.test(s)) maxN = Math.max(maxN, parseInt(s,10));
        }
      }
      return maxN;
    }
    function nextAutoPoint(){
      if (!Number.isFinite(state.meta.nextPoint) || state.meta.nextPoint < 1){
        state.meta.nextPoint = getMaxNumericPoint() + 1;
        if (state.meta.nextPoint < 1) state.meta.nextPoint = 1;
      }
      const n = state.meta.nextPoint;
      state.meta.nextPoint += 1;
      saveMeta();
      return String(n);
    }
    function undoAutoPoint(){
      state.meta.nextPoint = Math.max(1, (state.meta.nextPoint || 2) - 1);
      saveMeta();
    }

    // ---------------- Site Photos (IndexedDB) ----------------
    async function compressImageFileToDataUrl(file, maxDim=1100, quality=0.78){
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onerror = () => reject(new Error("File read failed"));
        fr.onload = () => {
          const img = new Image();
          img.onload = () => {
            const w = img.width, h = img.height;
            const scale = Math.min(1, maxDim / Math.max(w, h));
            const cw = Math.round(w * scale);
            const ch = Math.round(h * scale);
            const canvas = document.createElement("canvas");
            canvas.width = cw; canvas.height = ch;
            const ctx = canvas.getContext("2d", { alpha:false });
            ctx.drawImage(img, 0, 0, cw, ch);
            resolve(canvas.toDataURL("image/jpeg", quality));
          };
          img.onerror = () => reject(new Error("Image load failed"));
          img.src = fr.result;
        };
        fr.readAsDataURL(file);
      });
    }

    async function addPhotos(files){
      for (const f of files){
        if (!f.type.startsWith("image/")) continue;
        const dataUrl = await compressImageFileToDataUrl(f, 1100, 0.78);
        const blob = await dataUrlToBlob(dataUrl);
        const key = "photo_" + uid();
        await idbPut(key, blob);
        state.sitePhotos.push({ id: uid(), name: f.name || "photo", key, captionTag: "" });
      }
      await renderPhotos();
      saveMeta();
      toast("Photos added");
    }

    async function removePhoto(photoId){
      const p = state.sitePhotos.find(x => x.id === photoId);
      if (p) await idbDel(p.key);
      state.sitePhotos = state.sitePhotos.filter(x => x.id !== photoId);
      await renderPhotos();
      saveMeta();
    }

    function setPhotoCaption(photoId, tag){
      const p = state.sitePhotos.find(x => x.id === photoId);
      if (!p) return;
      p.captionTag = (p.captionTag === tag) ? "" : tag;
      renderPhotos();
      saveMeta();
    }

    async function renderPhotos(){
      photoRow.innerHTML = "";
      for (const p of state.sitePhotos){
        const blob = await idbGet(p.key);
        const url = blobToObjectURL(blob);

        const chipsHtml = PHOTO_CAPTION_CHIPS.map(tag => {
          const on = (p.captionTag || "") === tag;
          return `<span class="chip ${on ? "on":""}" data-photo-chip="${escapeHtml(tag)}" data-photo-id="${p.id}">${escapeHtml(tag)}</span>`;
        }).join("");

        const d = document.createElement("div");
        d.className = "thumb";
        d.innerHTML = `
          <button class="x" type="button" data-photo-remove="${p.id}" title="Remove">×</button>
          <img src="${url}" alt="${escapeHtml(p.name)}"/>
          <div class="cap">${escapeHtml(p.name)}</div>
          <div class="photoChips">
            <div class="chips">${chipsHtml}</div>
          </div>
        `;
        photoRow.appendChild(d);

        // avoid URL leaks
        d.querySelector("img").addEventListener("load", () => URL.revokeObjectURL(url), { once:true });
        d.querySelector("img").addEventListener("error", () => URL.revokeObjectURL(url), { once:true });
      }
    }

    // ---------------- Plot Plan (IndexedDB) ----------------
    async function fileToArrayBuffer(file){
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onerror = () => reject(new Error("Read failed"));
        fr.onload = () => resolve(fr.result);
        fr.readAsArrayBuffer(file);
      });
    }

    async function compressImageToBlob(file, maxDim=1500, quality=0.78){
      const dataUrl = await compressImageFileToDataUrl(file, maxDim, quality);
      return await dataUrlToBlob(dataUrl);
    }

    async function renderPdfFirstPageToBlob(file, maxWidth = 1000) {
      if (!window.pdfjsLib) throw new Error("PDF.js did not load.");
      const ab = await fileToArrayBuffer(file);
      const loadingTask = pdfjsLib.getDocument({ data: ab, disableAutoFetch:true, disableStream:true });
      const pdf = await loadingTask.promise;
      const page = await pdf.getPage(1);

      const viewport1 = page.getViewport({ scale: 1 });
      const scale = Math.min(2.0, maxWidth / viewport1.width);
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d", { alpha:false });
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      await page.render({ canvasContext: ctx, viewport }).promise;

      return await new Promise((resolve) => canvas.toBlob(resolve, "image/jpeg", 0.80));
    }

    async function setPlotPlanFromFile(file){
      const isPdf = file.type === "application/pdf" || (file.name||"").toLowerCase().endsWith(".pdf");
      let blob, kind = "image";

      if (isPdf){
        kind = "pdf";
        blob = await renderPdfFirstPageToBlob(file, 1000);
      } else if (file.type.startsWith("image/")){
        kind = "image";
        blob = await compressImageToBlob(file, 1500, 0.78);
      } else {
        throw new Error("Unsupported file type");
      }

      const key = "plan_" + uid();
      await idbPut(key, blob);

      // cleanup old plan blob
      if (state.plan?.key) await idbDel(state.plan.key);

      state.plan = { key, name: file.name || "plot-plan", kind };
      state.markers = [];
      state.ui.slopePick = null;
      state.meta.nextPoint = Math.max(1, getMaxNumericPoint() + 1);

      await renderPlan();
      saveMeta();
      toast("Plot plan loaded");
    }

    // ---------------- Plan Markers + Collisions ----------------
    const LABEL_W_PX = 30;
    const LABEL_H_PX = 12;
    const LABEL_PAD_PX = 3;

    function labelDimsPct(){
      const rect = planStage.getBoundingClientRect();
      const wPct = ((LABEL_W_PX + LABEL_PAD_PX) / Math.max(1, rect.width)) * 100;
      const hPct = ((LABEL_H_PX + LABEL_PAD_PX) / Math.max(1, rect.height)) * 100;
      return { wPct, hPct };
    }
    function boxesOverlap(a,b){ return !(a.x2 <= b.x1 || a.x1 >= b.x2 || a.y2 <= b.y1 || a.y1 >= b.y2); }
    function elevBox(m, wPct, hPct){
      const x1 = m.labelXPct;
      const x2 = m.labelXPct + wPct;
      const y1 = m.labelYPct - hPct/2;
      const y2 = m.labelYPct + hPct/2;
      return { x1,y1,x2,y2 };
    }
    function seedLabelPosition(m){
      m.labelXPct = (m.labelXPct ?? clamp(m.xPct + 0.9, 0, 100));
      m.labelYPct = (m.labelYPct ?? m.yPct);
    }
    function resolveLabelCollisions(){
      if (!state.plan || state.markers.length < 2) return;
      const { wPct, hPct } = labelDimsPct();
      const maxIter = 220;

      for (const m of state.markers){
        m.labelXPct = clamp(m.labelXPct, 0, 100 - wPct);
        m.labelYPct = clamp(m.labelYPct, hPct/2, 100 - hPct/2);
      }

      for (let iter=0; iter<maxIter; iter++){
        let moved = false;

        for (let i=0; i<state.markers.length; i++){
          for (let j=i+1; j<state.markers.length; j++){
            const a = state.markers[i], b = state.markers[j];
            const A = elevBox(a,wPct,hPct);
            const B = elevBox(b,wPct,hPct);
            if (!boxesOverlap(A,B)) continue;

            moved = true;
            const dy = (a.labelYPct - b.labelYPct) || (Math.random()-0.5);
            const dx = (a.labelXPct - b.labelXPct) || (Math.random()-0.5);

            const stepY = (hPct * 0.22) * Math.sign(dy);
            const stepX = (wPct * 0.10) * Math.sign(dx);

            a.labelYPct = clamp(a.labelYPct + stepY, hPct/2, 100 - hPct/2);
            b.labelYPct = clamp(b.labelYPct - stepY, hPct/2, 100 - hPct/2);

            a.labelXPct = clamp(a.labelXPct + stepX, 0, 100 - wPct);
            b.labelXPct = clamp(b.labelXPct - stepX, 0, 100 - wPct);
          }
        }

        if (!moved) break;
      }
    }

    // ---------------- Slope overlay ----------------
    function clearPlanOverlay(){ planOverlay.innerHTML = ""; }
    function pctToOverlay(xPct, yPct){ return { x:(xPct/100)*1000, y:(yPct/100)*1000 }; }

    function markerByLabel(label){
      const p = String(label||"").trim();
      return state.markers.find(m => String(m.pointLabel||"").trim() === p) || null;
    }

    function shotByLabel(label){
      const p = String(label||"").trim();
      for (const setup of state.setups){
        for (const sh of (setup.shots||[])){
          if (String(sh.label||"").trim() === p) return { setup, shot: sh };
        }
      }
      return null;
    }

    function slopePercentFromLabels(fromLabel, toLabel, runM){
      const A = shotByLabel(fromLabel);
      const B = shotByLabel(toLabel);
      if (!A || !B) return null;

      const eA = parseNumber(A.shot.elev);
      const eB = parseNumber(B.shot.elev);
      const run = parseNumber(runM);
      if (!Number.isFinite(eA) || !Number.isFinite(eB) || !Number.isFinite(run) || run <= 0) return null;

      // elev diff in cm, run in m -> slope% = |cm| / m
      return Math.abs(eB - eA) / run;
    }

    function drawPlanArrows(){
      clearPlanOverlay();
      if (!state.plan) return;

      const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
      const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
      marker.setAttribute("id", "arrowHead");
      marker.setAttribute("markerWidth", "6");
      marker.setAttribute("markerHeight", "6");
      marker.setAttribute("refX", "5.2");
      marker.setAttribute("refY", "2.5");
      marker.setAttribute("orient", "auto");
      marker.setAttribute("markerUnits", "strokeWidth");

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", "M0,0 L6,2.5 L0,5 Z");
      path.setAttribute("fill", "rgba(239,68,68,0.92)");
      marker.appendChild(path);
      defs.appendChild(marker);
      planOverlay.appendChild(defs);

      for (const sr of state.slopeRows){
        const from = (sr.fromLabel||"").trim();
        const to   = (sr.toLabel||"").trim();
        const run  = parseNumber(sr.distanceM);
        if (!from || !to || !Number.isFinite(run) || run<=0) continue;

        const mkFrom = markerByLabel(from);
        const mkTo   = markerByLabel(to);
        if (!mkFrom || !mkTo) continue;

        const Ashot = shotByLabel(from);
        const Bshot = shotByLabel(to);
        if (!Ashot || !Bshot) continue;

        const eA = parseNumber(Ashot.shot.elev);
        const eB = parseNumber(Bshot.shot.elev);
        if (!Number.isFinite(eA) || !Number.isFinite(eB)) continue;

        // arrow points downhill: higher elev -> lower elev
        const highIsFrom = eA >= eB;
        const mkHigh = highIsFrom ? mkFrom : mkTo;
        const mkLow  = highIsFrom ? mkTo   : mkFrom;

        const sPct = slopePercentFromLabels(from, to, run);
        if (!Number.isFinite(sPct)) continue;

        const P1 = pctToOverlay(mkHigh.xPct, mkHigh.yPct);
        const P2 = pctToOverlay(mkLow.xPct,  mkLow.yPct);

        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", P1.x);
        line.setAttribute("y1", P1.y);
        line.setAttribute("x2", P2.x);
        line.setAttribute("y2", P2.y);
        line.setAttribute("stroke", "rgba(239,68,68,0.88)");
        line.setAttribute("stroke-width", "1.8");
        line.setAttribute("stroke-linecap", "round");
        line.setAttribute("marker-end", "url(#arrowHead)");
        planOverlay.appendChild(line);

        const mx = (P1.x + P2.x) / 2;
        const my = (P1.y + P2.y) / 2;

        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", mx);
        text.setAttribute("y", my);
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("dominant-baseline", "central");
        text.setAttribute("class", "slopeLabel");
        text.textContent = `${(Math.round(sPct*100)/100).toFixed(2)}%`;
        planOverlay.appendChild(text);
      }
    }

    // ---------------- Plan render ----------------
    function markerPassFail(label){
      const tol = tolByAreaCm[state.meta.area] ?? 15;
      const ref = shotByLabel(label);
      if (!ref) return "na";
      const delta = calcDeltaCm(ref.shot.elev, ref.shot.designElev);
      if (!Number.isFinite(delta)) return "na";
      return Math.abs(delta) <= tol ? "pass" : "fail";
    }

    async function renderPlan(){
      planStage.querySelectorAll(".mkAnchor, .mkElev").forEach(n => n.remove());
      clearPlanOverlay();

      if (!state.plan){
        planWrap.style.display = "none";
        planEmpty.style.display = "block";
        return;
      }

      // load plan blob from idb -> object URL for display
      const blob = await idbGet(state.plan.key);
      if (!blob){
        planWrap.style.display = "none";
        planEmpty.style.display = "block";
        return;
      }

      if (state.planObjectURL) URL.revokeObjectURL(state.planObjectURL);
      state.planObjectURL = blobToObjectURL(blob);

      planWrap.style.display = "block";
      planEmpty.style.display = "none";

      planImg.src = state.planObjectURL;
      planName.textContent = state.plan.name || "Plot plan";
      planType.textContent = state.plan.kind === "pdf" ? "PDF (page 1 rendered)" : "Image";

      for (const m of state.markers) seedLabelPosition(m);
      resolveLabelCollisions();

      for (const m of state.markers){
        const cls = markerPassFail(m.pointLabel);

        const a = document.createElement("div");
        a.className = "mkAnchor";
        if (state.ui.slopePick && state.ui.slopePick === m.pointLabel) a.classList.add("sel");
        a.style.left = m.xPct + "%";
        a.style.top  = m.yPct + "%";
        a.dataset.id = m.id;
        a.dataset.point = m.pointLabel;
        a.title = `Point ${m.pointLabel}`;
        a.innerHTML = `<span>${escapeHtml(m.pointLabel)}</span>`;
        planStage.appendChild(a);

        const ref = shotByLabel(m.pointLabel);
        const elevTxt = ref?.shot?.elev ? String(ref.shot.elev) : "";

        const e = document.createElement("div");
        e.className = "mkElev";
        e.style.left = m.labelXPct + "%";
        e.style.top  = m.labelYPct + "%";
        e.innerHTML = `<div class="el ${cls}">${escapeHtml(elevTxt)}</div>`;
        planStage.appendChild(e);
      }

      drawPlanArrows();
      saveMeta();
    }

    // ---------------- Setup & Shot add/remove ----------------
    function addSetup(){
      const s = {
        id: uid(),
        name: "Setup",
        bs: "",
        hi: "",
        fs: "",
        ifs: "",
        elev: "",
        shots: []
      };
      state.setups.push(s);
      state.meta.activeSetupId = s.id;
      renderActiveSetupSelect();
      renderShotsTable();
      saveMeta();
      toast("Setup added");
    }

    function addShotToActiveSetup(labelOverride=null){
      const setup = state.setups.find(x => x.id === state.meta.activeSetupId) || state.setups[0];
      if (!setup) { addSetup(); return; }

      const label = labelOverride ? String(labelOverride).trim() : nextAutoPoint();
      const sh = {
        id: uid(),
        label,
        ifs: "",
        elev: "",
        designElev: "",
        note: ""
      };
      setup.shots.push(sh);
      renderShotsTable();
      saveMeta();
      toast("Shot added");
    }

    function removeSelectedRows(){
      const sels = Array.from(document.querySelectorAll(".selRow:checked"));
      if (!sels.length) return;

      // remove shots first, then setups
      const toRemoveShots = sels.filter(x => x.dataset.kind === "shot").map(x => ({ setupId:x.dataset.setup, id:x.dataset.id }));
      const toRemoveSetups = sels.filter(x => x.dataset.kind === "setup").map(x => x.dataset.setup);

      // remove shots + related markers
      for (const r of toRemoveShots){
        const setup = state.setups.find(s => s.id === r.setupId);
        if (!setup) continue;

        const shot = (setup.shots||[]).find(sh => sh.id === r.id);
        const label = shot?.label;

        setup.shots = (setup.shots||[]).filter(sh => sh.id !== r.id);

        if (label){
          state.markers = state.markers.filter(m => String(m.pointLabel||"") !== String(label));
        }
      }

      // remove setups + their shots + markers
      for (const sid of toRemoveSetups){
        const setup = state.setups.find(s => s.id === sid);
        if (!setup) continue;

        const labels = new Set((setup.shots||[]).map(sh => String(sh.label||"")));
        state.markers = state.markers.filter(m => !labels.has(String(m.pointLabel||"")));
        state.setups = state.setups.filter(s => s.id !== sid);
      }

      // reset active setup if missing
      if (state.setups.length){
        if (!state.setups.find(s => s.id === state.meta.activeSetupId)){
          state.meta.activeSetupId = state.setups[0].id;
        }
      } else {
        state.meta.activeSetupId = "";
      }

      state.meta.nextPoint = Math.max(1, getMaxNumericPoint() + 1);
      renderActiveSetupSelect();
      renderShotsTable();
      renderSlopes();
      renderPlan();
      saveMeta();
      toast("Removed");
    }

    // ---------------- Editing + auto-calc behavior ----------------
    function findSetupById(id){ return state.setups.find(s => s.id === id) || null; }
    function findShot(setupId, shotId){
      const setup = findSetupById(setupId);
      if (!setup) return null;
      const shot = (setup.shots||[]).find(sh => sh.id === shotId) || null;
      return { setup, shot };
    }

    function normalizeLabel(label){
      return String(label||"").trim();
    }

    // Keep marker label in sync if label changed
    function syncMarkerLabel(oldLabel, newLabel){
      for (const m of state.markers){
        if (String(m.pointLabel||"") === String(oldLabel)){
          m.pointLabel = newLabel;
        }
      }
      // slope rows reference labels too
      for (const sr of state.slopeRows){
        if (sr.fromLabel === oldLabel) sr.fromLabel = newLabel;
        if (sr.toLabel === oldLabel) sr.toLabel = newLabel;
      }
    }

    // ---------------- Plot plan point panel ----------------
    const panelState = { mode:null, markerId:null, pending:null };

    function openOverlay(){ overlay.style.display = "flex"; }
    function closeOverlay(){
      overlay.style.display = "none";
      panelBody.innerHTML = "";
      panelActions.innerHTML = "";
      panelTitle.textContent = "Entry";
      panelState.mode = null;
      panelState.markerId = null;
      panelState.pending = null;
    }
    btnPanelClose.addEventListener("click", closeOverlay);
    overlay.addEventListener("click", (e) => { if (e.target === overlay) closeOverlay(); });

    function openShotPanelNew(xPct, yPct){
      const setup = state.setups.find(s => s.id === state.meta.activeSetupId);
      if (!setup){
        addSetup();
        return openShotPanelNew(xPct, yPct);
      }

      const autoPoint = nextAutoPoint();
      panelState.mode = "shot-new";
      panelState.pending = { xPct, yPct, labelXPct: xPct + 0.9, labelYPct: yPct, pointLabel:autoPoint, ifs:"", elev:"", designElev:"", note:"" };

      panelTitle.textContent = `Add Shot to ${setup.name || "Setup"}`;

      panelBody.innerHTML = `
        <div class="panelGrid">
          <div>
            <label>Point Label</label>
            <input id="pp_point" class="mini" value="${escapeHtml(autoPoint)}" inputmode="text" autocomplete="off"
              placeholder="e.g., 1, 1.1, 1A, TC-1" />
          </div>
          <div>
            <label>Point Note</label>
            <div class="chips" id="pp_notechips">${POINT_NOTE_CHIPS.map(c => `<span class="chip" data-panel-chip="${escapeHtml(c)}">${escapeHtml(c)}</span>`).join("")}</div>
          </div>

          <div>
            <label>IFS (optional)</label>
            <input id="pp_ifs" class="mini" type="number" step="any" inputmode="decimal" placeholder="IFS" />
          </div>

          <div>
            <label>Field Elevation (optional)</label>
            <input id="pp_elev" class="mini" type="number" step="any" inputmode="decimal" placeholder="ELEV" />
          </div>

          <div>
            <label>Design Elevation (required)</label>
            <input id="pp_design" class="mini" type="number" step="any" inputmode="decimal" placeholder="Designed" />
          </div>

          <div>
            <label>Setup HI (used for calc)</label>
            <input class="mini" value="${escapeHtml(setup.hi||"")}" disabled />
          </div>
        </div>
        <div class="hint">Enter either IFS or ELEV (one is enough). With HI, the form will compute the other.</div>
      `;

      panelActions.innerHTML = `
        <button class="btn ghost" id="pp_cancel" type="button">Cancel</button>
        <button class="btn primary" id="pp_save" type="button">Save Shot</button>
      `;

      openOverlay();

      const elPoint = document.getElementById("pp_point");
      const elIFS = document.getElementById("pp_ifs");
      const elElev = document.getElementById("pp_elev");
      const elDesign = document.getElementById("pp_design");

      // focus to design (they read from plan), but keep numeric keypad for elevs
      setTimeout(() => { elDesign.focus(); elDesign.select(); }, 60);

      // chips
      document.getElementById("pp_notechips").addEventListener("click", (e) => {
        const chip = e.target.closest("[data-panel-chip]");
        if (!chip) return;
        const val = chip.dataset.panelChip;
        panelState.pending.note = (panelState.pending.note === val) ? "" : val;
        document.querySelectorAll("#pp_notechips .chip").forEach(c => c.classList.remove("on"));
        if (panelState.pending.note){ chip.classList.add("on"); }
      });

      // auto-calc as user types (HI-based)
      function recalc(){
        const H = parseNumber(setup.hi);
        const I = parseNumber(elIFS.value);
        const E = parseNumber(elElev.value);

        if (Number.isFinite(H) && Number.isFinite(E) && !Number.isFinite(I)){
          const autoI = computeIFS(H, E);
          if (Number.isFinite(autoI)) elIFS.value = String(autoI);
        } else if (Number.isFinite(H) && Number.isFinite(I) && !Number.isFinite(E)){
          const autoE = computeElev(H, I);
          if (Number.isFinite(autoE)) elElev.value = String(autoE);
        }
      }
      elIFS.addEventListener("input", recalc);
      elElev.addEventListener("input", recalc);

      document.getElementById("pp_cancel").addEventListener("click", () => {
        undoAutoPoint();
        closeOverlay();
      });

      document.getElementById("pp_save").addEventListener("click", () => {
        const p = normalizeLabel(elPoint.value);
        const ifs = String(elIFS.value||"").trim();
        const elev = String(elElev.value||"").trim();
        const des = String(elDesign.value||"").trim();

        if (!p){ alert("Point label is required."); return; }
        if (!des){ alert("Design elevation is required."); elDesign.focus(); return; }

        // require either ifs or elev
        if (!ifs && !elev){
          alert("Enter either IFS or Field Elevation.");
          return;
        }

        // ensure unique point label across all shots
        const exists = shotByLabel(p);
        if (exists){ alert("That point label already exists."); return; }

        // compute missing if possible
        const H = parseNumber(setup.hi);
        let finalIFS = parseNumber(ifs);
        let finalElev = parseNumber(elev);

        if (Number.isFinite(H)){
          if (Number.isFinite(finalElev) && !Number.isFinite(finalIFS)){
            finalIFS = computeIFS(H, finalElev);
          } else if (Number.isFinite(finalIFS) && !Number.isFinite(finalElev)){
            finalElev = computeElev(H, finalIFS);
          }
        }

        const sh = { id: uid(), label: p, ifs: Number.isFinite(finalIFS)? String(finalIFS): (ifs||""), elev: Number.isFinite(finalElev)? String(finalElev): (elev||""), designElev: des, note: panelState.pending.note || "" };
        setup.shots.push(sh);

        // add marker tied to shot
        state.markers.push({
          id: uid(),
          xPct: panelState.pending.xPct,
          yPct: panelState.pending.yPct,
          labelXPct: panelState.pending.labelXPct,
          labelYPct: panelState.pending.labelYPct,
          pointLabel: p,
          shotId: sh.id
        });

        closeOverlay();
        renderShotsTable();
        renderSlopes();
        renderPlan();
        saveMeta();
        toast("Shot saved");
      });
    }

    function openShotPanelEdit(markerId){
      const mk = state.markers.find(m => m.id === markerId);
      if (!mk) return;

      const found = shotByLabel(mk.pointLabel);
      if (!found) return;

      const { setup, shot } = found;
      panelState.mode = "shot-edit";
      panelState.markerId = markerId;

      panelTitle.textContent = `Edit Shot (${setup.name || "Setup"})`;

      panelBody.innerHTML = `
        <div class="panelGrid">
          <div>
            <label>Point Label</label>
            <input id="pp_point" class="mini" value="${escapeHtml(shot.label||"")}" inputmode="text" autocomplete="off" />
          </div>

          <div>
            <label>Point Note</label>
            <div class="chips" id="pp_notechips">
              ${POINT_NOTE_CHIPS.map(c => `<span class="chip ${shot.note===c?"on":""}" data-panel-chip="${escapeHtml(c)}">${escapeHtml(c)}</span>`).join("")}
            </div>
          </div>

          <div>
            <label>IFS</label>
            <input id="pp_ifs" class="mini" type="number" step="any" inputmode="decimal" value="${escapeHtml(shot.ifs||"")}" />
          </div>

          <div>
            <label>Field Elevation</label>
            <input id="pp_elev" class="mini" type="number" step="any" inputmode="decimal" value="${escapeHtml(shot.elev||"")}" />
          </div>

          <div>
            <label>Design Elevation</label>
            <input id="pp_design" class="mini" type="number" step="any" inputmode="decimal" value="${escapeHtml(shot.designElev||"")}" />
          </div>

          <div>
            <label>Setup HI (used for calc)</label>
            <input class="mini" value="${escapeHtml(setup.hi||"")}" disabled />
          </div>
        </div>
        <div class="hint">Edit IFS or ELEV, the other will auto-calc if HI is present.</div>
      `;

      panelActions.innerHTML = `
        <button class="btn danger" id="pp_delete" type="button">Delete</button>
        <button class="btn ghost" id="pp_cancel" type="button">Cancel</button>
        <button class="btn primary" id="pp_save" type="button">Save</button>
      `;

      openOverlay();

      const elPoint = document.getElementById("pp_point");
      const elIFS = document.getElementById("pp_ifs");
      const elElev = document.getElementById("pp_elev");
      const elDesign = document.getElementById("pp_design");

      setTimeout(() => { elElev.focus(); elElev.select(); }, 60);

      document.getElementById("pp_notechips").addEventListener("click", (e) => {
        const chip = e.target.closest("[data-panel-chip]");
        if (!chip) return;
        const val = chip.dataset.panelChip;
        shot.note = (shot.note === val) ? "" : val;
        document.querySelectorAll("#pp_notechips .chip").forEach(c => c.classList.remove("on"));
        if (shot.note){ chip.classList.add("on"); }
      });

      function recalc(){
        const H = parseNumber(setup.hi);
        const I = parseNumber(elIFS.value);
        const E = parseNumber(elElev.value);

        if (Number.isFinite(H) && Number.isFinite(E) && !Number.isFinite(I)){
          const autoI = computeIFS(H, E);
          if (Number.isFinite(autoI)) elIFS.value = String(autoI);
        } else if (Number.isFinite(H) && Number.isFinite(I) && !Number.isFinite(E)){
          const autoE = computeElev(H, I);
          if (Number.isFinite(autoE)) elElev.value = String(autoE);
        }
      }
      elIFS.addEventListener("input", recalc);
      elElev.addEventListener("input", recalc);

      document.getElementById("pp_cancel").addEventListener("click", closeOverlay);

      document.getElementById("pp_delete").addEventListener("click", () => {
        if (!confirm("Delete this shot and its marker?")) return;

        // remove shot
        setup.shots = (setup.shots||[]).filter(x => x.id !== shot.id);
        // remove marker
        state.markers = state.markers.filter(m => m.id !== markerId);
        // remove slope rows referencing it
        state.slopeRows = state.slopeRows.filter(sr => sr.fromLabel !== shot.label && sr.toLabel !== shot.label);

        closeOverlay();
        renderShotsTable();
        renderSlopes();
        renderPlan();
        saveMeta();
        toast("Deleted");
      });

      document.getElementById("pp_save").addEventListener("click", () => {
        const oldLabel = shot.label;
        const newLabel = normalizeLabel(elPoint.value);
        const ifs = String(elIFS.value||"").trim();
        const elev = String(elElev.value||"").trim();
        const des = String(elDesign.value||"").trim();

        if (!newLabel){ alert("Point label is required."); return; }
        if (!des){ alert("Design elevation is required."); return; }
        if (!ifs && !elev){ alert("Enter either IFS or Field Elevation."); return; }

        // ensure unique label (except this shot)
        const exists = shotByLabel(newLabel);
        if (exists && exists.shot.id !== shot.id){
          alert("That point label already exists.");
          return;
        }

        // compute missing if possible
        const H = parseNumber(setup.hi);
        let finalIFS = parseNumber(ifs);
        let finalElev = parseNumber(elev);

        if (Number.isFinite(H)){
          if (Number.isFinite(finalElev) && !Number.isFinite(finalIFS)){
            finalIFS = computeIFS(H, finalElev);
          } else if (Number.isFinite(finalIFS) && !Number.isFinite(finalElev)){
            finalElev = computeElev(H, finalIFS);
          }
        }

        shot.label = newLabel;
        shot.ifs = Number.isFinite(finalIFS)? String(finalIFS): ifs;
        shot.elev = Number.isFinite(finalElev)? String(finalElev): elev;
        shot.designElev = des;

        if (oldLabel !== newLabel){
          syncMarkerLabel(oldLabel, newLabel);
        }

        closeOverlay();
        renderShotsTable();
        renderSlopes();
        renderPlan();
        saveMeta();
        toast("Saved");
      });
    }

    // ---------------- Slopes table ----------------
    function pointLabelOptions(){
      const names = [];
      for (const s of state.setups){
        for (const sh of (s.shots||[])){
          const v = String(sh.label||"").trim();
          if (v) names.push(v);
        }
      }
      return Array.from(new Set(names));
    }

    function selectHtml(rowId, key, current, options){
      const cur = (current||"").trim();
      const opts = options.map(n => `<option value="${escapeHtml(n)}" ${n===cur?"selected":""}>${escapeHtml(n)}</option>`).join("");
      return `<select class="mini" data-type="slope" data-k="${key}" data-id="${rowId}">
        <option value="">Select…</option>${opts}
      </select>`;
    }

    function renderSlopes(){
      const options = pointLabelOptions();
      slopeBody.innerHTML = "";

      for (const r of state.slopeRows){
        const runM = parseNumber(r.distanceM);
        const sPct = slopePercentFromLabels(r.fromLabel, r.toLabel, runM);

        const tr = document.createElement("tr");
        tr.dataset.rowId = r.id;
        tr.innerHTML = `
          <td><input type="checkbox" class="slopeSel" data-id="${r.id}"></td>
          <td><input class="mini" data-type="slope" data-k="segment" data-id="${r.id}" value="${escapeHtml(r.segment||"")}" placeholder="e.g., Front swale" /></td>
          <td>${selectHtml(r.id,"fromLabel",r.fromLabel,options)}</td>
          <td>${selectHtml(r.id,"toLabel",r.toLabel,options)}</td>
          <td><input class="mini" type="number" step="any" inputmode="decimal" data-type="slope" data-k="distanceM" data-id="${r.id}" value="${escapeHtml(r.distanceM||"")}" placeholder="Run (m)" /></td>
          <td><span class="delta na">${Number.isFinite(sPct) ? (Math.round(sPct*100)/100).toFixed(2) : "—"}</span></td>
        `;
        slopeBody.appendChild(tr);
      }

      drawPlanArrows();
      saveMeta();
    }

    // ---------------- Office Summary ----------------
    function selectedNotesText(){
      const picked = [];
      NOTE_CHECKS.forEach((n, i) => {
        if (state.noteChecks[i]) picked.push(`${n.title}: ${n.text}`);
      });
      return picked;
    }

    function buildOfficeSummaryText(){
      const tol = tolByAreaCm[state.meta.area] ?? 15;

      let checked=0, fails=0, worstAbs=null, worst=null, worstPoint=null;
      const failList = [];

      for (const s of state.setups){
        for (const sh of (s.shots||[])){
          const delta = calcDeltaCm(sh.elev, sh.designElev);
          if (!Number.isFinite(delta)) continue;
          checked++;
          if (Math.abs(delta) > tol){
            fails++;
            failList.push(`${(sh.label||"").trim()}: ${Math.round(delta*10)/10} cm (${sh.note||"no note"})`);
          }
          const abs = Math.abs(delta);
          if (worstAbs===null || abs>worstAbs){
            worstAbs = abs; worst = delta; worstPoint = (sh.label||"").trim();
          }
        }
      }

      const slopeLines = [];
      for (const sr of state.slopeRows){
        const run = parseNumber(sr.distanceM);
        const p = slopePercentFromLabels(sr.fromLabel, sr.toLabel, run);
        if (Number.isFinite(p)){
          slopeLines.push(`${(sr.segment||"Slope").trim()} (${(sr.fromLabel||"").trim()}↔${(sr.toLabel||"").trim()}): ${(Math.round(p*100)/100).toFixed(2)}% downhill`);
        }
      }

      const notesPicked = selectedNotesText();
      const photoCaps = state.sitePhotos
        .filter(p => (p.captionTag||"").trim())
        .map(p => `${p.captionTag}: ${p.name}`);

      const lines = [];
      lines.push(`Tolerance ±${tol} cm (${state.meta.area}).`);
      lines.push(`${state.setups.length} setup(s), ${checked} shot(s) checked, ${fails} out of tolerance.`);
      if (worstPoint && worst!==null) lines.push(`Largest variance ${Math.round(worst*10)/10} cm at Point ${worstPoint}.`);
      if (failList.length) lines.push(`Out-of-tolerance: ${failList.join("; ")}.`);
      if (slopeLines.length) lines.push(`Slopes: ${slopeLines.join("; ")}.`);
      if (notesPicked.length) lines.push(`Site notes: ${notesPicked.join(" | ")}.`);
      lines.push(`Photos attached: ${state.sitePhotos.length}.`);
      if (photoCaps.length) lines.push(`Photo captions: ${photoCaps.join("; ")}.`);

      return lines.join("\n");
    }

    // ---------------- PDF Export + Share ----------------
    function waitImagesLoaded(container){
      const imgs = Array.from(container.querySelectorAll("img"));
      if (!imgs.length) return Promise.resolve();
      return Promise.all(imgs.map(img => {
        if (img.complete && img.naturalWidth > 0) return Promise.resolve();
        return new Promise(res => {
          const done = () => res();
          img.addEventListener("load", done, { once:true });
          img.addEventListener("error", done, { once:true });
        });
      })).then(() => undefined);
    }

    async function buildExportPlanMarkup(container){
      // container must have .planPrintStage and .planPrintOverlay
      const stage = container.querySelector(".planPrintStage");
      const overlayDiv = container.querySelector(".planPrintOverlay");
      if (!stage || !overlayDiv) return;

      // add markers + labels
      overlayDiv.innerHTML = "";

      for (const m of state.markers){
        const cls = markerPassFail(m.pointLabel);

        const a = document.createElement("div");
        a.className = "mkAnchorPrint";
        a.style.left = m.xPct + "%";
        a.style.top  = m.yPct + "%";
        a.innerHTML = `<span>${escapeHtml(m.pointLabel)}</span>`;
        overlayDiv.appendChild(a);

        const ref = shotByLabel(m.pointLabel);
        const elevTxt = ref?.shot?.elev ? String(ref.shot.elev) : "";

        const e = document.createElement("div");
        e.className = "mkElevPrint";
        e.style.left = (m.labelXPct ?? (m.xPct+0.9)) + "%";
        e.style.top  = (m.labelYPct ?? m.yPct) + "%";
        e.innerHTML = `<div class="el ${cls}">${escapeHtml(elevTxt)}</div>`;
        overlayDiv.appendChild(e);
      }
    }

    async function buildReportElement(){
      exportHost.innerHTML = "";

      const tol = tolByAreaCm[state.meta.area] ?? 15;
      const summaryText = (officeSummary.value||"").trim() || buildOfficeSummaryText();

      const root = document.createElement("div");
      root.className = "report";

      root.innerHTML = `
        <div class="reportHeader">
          <div class="reportLogo"><img src="vista-geomatics.png" alt="Logo"/></div>
          <div>
            <p class="reportTitle">Vista Geomatics, Grading Check Report</p>
            <p class="reportSub">Tolerance: ±${tol} cm, Area: ${escapeHtml(state.meta.area)}</p>
          </div>
        </div>

        <div class="reportMeta">
          <div><b>Job Number:</b> ${escapeHtml(state.meta.jobNo||"")}</div>
          <div><b>Date:</b> ${escapeHtml(state.meta.jobDate||"")}</div>
          <div><b>Community:</b> ${escapeHtml(state.meta.community||"")}</div>
          <div><b>Address:</b> ${escapeHtml(state.meta.address||"")}</div>
          <div><b>Lot/Block/Plan:</b> ${escapeHtml(state.meta.lotBlockPlan||"")}</div>
          <div><b>Crew Chief:</b> ${escapeHtml(state.meta.crewChief||"")}</div>
        </div>

        <div class="reportSectionTitle">Office Summary</div>
        <div style="border:1px solid #d6dee9; border-radius:12px; padding:10px; font-size:11px; color:#334155; white-space:pre-wrap; background:#fbfdff;">
          ${escapeHtml(summaryText)}
        </div>
      `;

      // --- Plot Plan page ---
      if (state.plan?.key){
        const planBlob = await idbGet(state.plan.key);
        if (planBlob){
          const url = blobToObjectURL(planBlob);
          const planPage = document.createElement("div");
          planPage.className = "pageBreak";
          planPage.innerHTML = `
            <div class="reportSectionTitle">Plot Plan</div>
            <div class="planPrintWrap">
              <div class="planPrintStage">
                <img src="${url}" alt="Plot Plan"/>
                <div class="planPrintOverlay"></div>
              </div>
            </div>
          `;
          root.appendChild(planPage);

          await new Promise(r => setTimeout(r, 0));
          await buildExportPlanMarkup(planPage);
        }
      }

      // --- Tables page ---
      const tables = document.createElement("div");
      tables.className = "pageBreak";

      // setup + shots rows (flatten for export)
      const rows = [];
      for (const s of state.setups){
        rows.push({ type:"SETUP", label:s.name, bs:s.bs, hi:s.hi, fs:s.fs, ifs:s.ifs, elev:s.elev, design:"", delta:"", status:"", note:"" });
        for (const sh of (s.shots||[])){
          const { delta, status } = calcShotStatus(s, sh);
          rows.push({
            type:"SHOT", label:sh.label, bs:"", hi:s.hi, fs:"", ifs:sh.ifs, elev:sh.elev,
            design:sh.designElev,
            delta: Number.isFinite(delta) ? (Math.round(delta*10)/10) : "",
            status,
            note: sh.note || ""
          });
        }
      }


      tables.innerHTML = `
        <div class="reportSectionTitle">Setups & Shots</div>
        <table class="reportTable">
          <thead>
            <tr>
              <th>Type</th><th>STA / Point</th><th>BS</th><th>HI</th><th>FS</th><th>IFS</th><th>ELEV</th><th>Designed</th><th>Δ (cm)</th><th>Status</th><th>Notes</th>
            </tr>
          </thead>
          <tbody>
            ${rows.map(r=>{
              const pill = r.status==="PASS" ? "pillSmall ok" : (r.status==="FAIL" ? "pillSmall bad" : "pillSmall");
              return `<tr>
                <td>${escapeHtml(r.type)}</td>
                <td>${escapeHtml(r.label||"")}</td>
                <td>${escapeHtml(r.bs||"")}</td>
                <td>${escapeHtml(r.hi||"")}</td>
                <td>${escapeHtml(r.fs||"")}</td>
                <td>${escapeHtml(r.ifs||"")}</td>
                <td>${escapeHtml(r.elev||"")}</td>
                <td>${escapeHtml(r.design||"")}</td>
                <td>${escapeHtml(String(r.delta||""))}</td>
                <td>${r.status ? `<span class="${pill}">${escapeHtml(r.status)}</span>` : ""}</td>
                <td>${escapeHtml(r.note||"")}</td>
              </tr>`;
            }).join("")}
          </tbody>
        </table>
      `;
      root.appendChild(tables);

      // --- Photos pages (4 per page) ---
      if (state.sitePhotos.length){
        const photosPage = document.createElement("div");
        photosPage.className = "pageBreak";
        photosPage.innerHTML = `<div class="reportSectionTitle">Site Photos</div>`;
        root.appendChild(photosPage);

        // chunk 4 per grid (2x2)
        for (let i=0; i<state.sitePhotos.length; i+=4){
          const chunk = state.sitePhotos.slice(i, i+4);
          const grid = document.createElement("div");
          grid.className = "photoGrid";
          grid.style.marginTop = "10px";

          for (const p of chunk){
            const blob = await idbGet(p.key);
            const url = blob ? blobToObjectURL(blob) : "";
            const cap = (p.captionTag ? `${p.captionTag}, ` : "") + (p.name||"Photo");
            const cell = document.createElement("div");
            cell.className = "photoCell";
            cell.innerHTML = `
              <img src="${url}" alt="Photo"/>
              <div class="pCap">${escapeHtml(cap)}</div>
            `;
            grid.appendChild(cell);
          }
          photosPage.appendChild(grid);
        }
      }

      exportHost.appendChild(root);
      return root;
    }

    async function exportPDF(){
      if (typeof html2pdf === "undefined"){ alert("PDF export library failed to load."); return; }
      const reportEl = await buildReportElement();
      await waitImagesLoaded(reportEl);

      const filename = defaultFileName("pdf");
      btnPDF.textContent = "Preparing...";
      btnPDF.disabled = true;

      try{
        await html2pdf().set({
          margin: [10,10,10,10],
          filename,
          image: { type:"jpeg", quality:0.95 },
          html2canvas: { scale: 2, useCORS:true, backgroundColor:"#ffffff" },
          jsPDF: { unit:"mm", format:"letter", orientation:"portrait" },
          pagebreak: { mode:["css","legacy"] }
        }).from(reportEl).save();
      } finally {
        btnPDF.textContent = "Download PDF";
        btnPDF.disabled = false;
        exportHost.innerHTML = "";
      }
    }

    async function sharePDF(){
      if (typeof html2pdf === "undefined"){ alert("Share requires the PDF export library."); return; }
      const reportEl = await buildReportElement();
      await waitImagesLoaded(reportEl);

      const filename = defaultFileName("pdf");
      btnShare.textContent = "Preparing...";
      btnShare.disabled = true;

      try{
        const opt = {
          margin: [10,10,10,10],
          image: { type:"jpeg", quality:0.95 },
          html2canvas: { scale: 2, useCORS:true, backgroundColor:"#ffffff" },
          jsPDF: { unit:"mm", format:"letter", orientation:"portrait" },
          pagebreak: { mode:["css","legacy"] }
        };

        const worker = html2pdf().set(opt).from(reportEl);
        const blob = await worker.outputPdf("blob");
        const file = new File([blob], filename, { type:"application/pdf" });

        if (navigator.share && navigator.canShare && navigator.canShare({ files:[file] })){
          await navigator.share({ title:"Vista Geomatics – Grading Check", text:"Grading check report attached.", files:[file] });
        } else {
          await html2pdf().set({ ...opt, filename }).from(reportEl).save();
          alert("Share not available in this browser, PDF downloaded instead.");
        }
      } finally {
        btnShare.textContent = "Share PDF";
        btnShare.disabled = false;
        exportHost.innerHTML = "";
      }
    }

    // ---------------- Slope Mode Toggle ----------------
    function setSlopeMode(on){
      state.ui.slopeMode = !!on;
      state.ui.slopePick = null;

      btnSlopeMode.textContent = `Slope Mode: ${state.ui.slopeMode ? "ON" : "OFF"}`;
      btnSlopeMode.classList.toggle("primary", state.ui.slopeMode);
      btnSlopeMode.classList.toggle("ghost", !state.ui.slopeMode);

      planHint.textContent = state.ui.slopeMode
        ? "Slope Mode ON: tap Point A then Point B. Add a slope row, enter run (m), arrow + % show on plan."
        : "Tap plan to add a shot (to the active setup). Tap point number to edit.";

      renderPlan();
      saveMeta();
    }

    // ---------------- Clear Form ----------------
    async function clearAll(){
      if (!confirm("Clear this grading check from this device? This removes plan/photos stored in IndexedDB too.")) return;

      // delete plan + photos from idb
      if (state.plan?.key) await idbDel(state.plan.key);
      for (const p of state.sitePhotos){
        await idbDel(p.key);
      }

      // reset state
      localStorage.removeItem(STORAGE_KEY);
      state.meta = { area:"calgary", jobNo:"", jobDate:todayISO(), community:"", address:"", lotBlockPlan:"", crewChief:"", officeSummary:"", nextPoint:1, activeSetupId:"" };
      state.noteChecks = NOTE_CHECKS.map(() => false);
      state.plan = null;
      state.planObjectURL = null;
      state.sitePhotos = [];
      state.markers = [];
      state.setups = [];
      state.slopeRows = [];
      state.ui = { slopeMode:false, slopePick:null };

      initDefaults();
      syncMetaToUI();
      renderTolerance();
      renderNotes();
      await renderPhotos();
      renderActiveSetupSelect();
      renderShotsTable();
      renderSlopes();
      await renderPlan();
      saveMeta();
      toast("Cleared");
    }

    // ---------------- Event Wiring ----------------
    areaSelect.addEventListener("change", () => {
      state.meta.area = areaSelect.value;
      renderTolerance();
      renderShotsTable();
      renderSlopes();
      renderPlan();
      saveMeta();
    });

    function bindMetaInput(el, key){
      el.addEventListener("input", () => { state.meta[key] = el.value; saveMeta(); });
    }
    bindMetaInput(jobNo,"jobNo");
    bindMetaInput(jobDate,"jobDate");
    bindMetaInput(community,"community");
    bindMetaInput(address,"address");
    bindMetaInput(lotBlockPlan,"lotBlockPlan");
    bindMetaInput(crewChief,"crewChief");

    btnSave.addEventListener("click", () => saveMeta(true));
    btnResetTop.addEventListener("click", clearAll);
    btnResetBottom.addEventListener("click", clearAll);

    btnPDF.addEventListener("click", exportPDF);
    btnShare.addEventListener("click", sharePDF);

    btnGenSummary.addEventListener("click", () => {
      officeSummary.value = buildOfficeSummaryText();
      state.meta.officeSummary = officeSummary.value;
      saveMeta();
      toast("Summary generated");
    });

    btnCopySummary.addEventListener("click", async () => {
      const text = (officeSummary.value||"").trim() || buildOfficeSummaryText();
      try{ await navigator.clipboard.writeText(text); toast("Copied"); }
      catch(e){
        officeSummary.focus(); officeSummary.select();
        document.execCommand("copy");
        toast("Copied");
      }
    });

    officeSummary.addEventListener("input", () => {
      state.meta.officeSummary = officeSummary.value;
      saveMeta();
    });

    noteList.addEventListener("change", (e) => {
      const cb = e.target;
      if (!cb || cb.type !== "checkbox") return;
      const idx = Number(cb.dataset.noteIdx);
      if (!Number.isFinite(idx)) return;
      state.noteChecks[idx] = cb.checked;
      saveMeta();
    });

    // setups
    activeSetup.addEventListener("change", () => {
      state.meta.activeSetupId = activeSetup.value;
      saveMeta();
    });

    btnAddSetup.addEventListener("click", addSetup);
    btnAddShot.addEventListener("click", () => addShotToActiveSetup(null));
    btnRemoveSelectedShots.addEventListener("click", removeSelectedRows);

    // handle chips + inputs in shots table
    shotsBody.addEventListener("click", (e) => {
      const chip = e.target.closest(".chip");
      if (!chip) return;

      const shotId = chip.dataset.row;
      const val = chip.dataset.chip;

      // find shot
      for (const setup of state.setups){
        const shot = (setup.shots||[]).find(sh => sh.id === shotId);
        if (!shot) continue;

        shot.note = val;
        // toggle UI
        shotsBody.querySelectorAll(`.chip[data-row="${CSS.escape(shotId)}"]`).forEach(c => c.classList.remove("on"));
        chip.classList.add("on");

        // sync note input
        const noteInput = shotsBody.querySelector(`input[data-kind="shot"][data-k="note"][data-id="${CSS.escape(shotId)}"]`);
        if (noteInput) noteInput.value = val;

        renderShotsTable();
        saveMeta();
        toast("Note set");
        break;
      }
    });

    shotsBody.addEventListener("input", (e) => {
      const t = e.target;
      if (!t?.dataset) return;

      const kind = t.dataset.kind;
      if (kind === "setup"){
        const setup = findSetupById(t.dataset.setup);
        if (!setup) return;

        const k = t.dataset.k;
        const oldName = setup.name;
        setup[k] = t.value;

        // auto-calc setup fields
        if (k === "bs" || k === "elev"){
          const autoHI = computeHIFromBS(setup.bs, setup.elev);
          if (Number.isFinite(autoHI) && !String(setup.hi||"").trim()){
            setup.hi = String(autoHI);
          }
        }
        if (k === "hi" || k === "bs"){
          const autoElev = computeElevFromBS(setup.hi, setup.bs);
          if (Number.isFinite(autoElev) && !String(setup.elev||"").trim()){
            setup.elev = String(autoElev);
          }
        }

        renderActiveSetupSelect();
        // keep active setup selection stable
        if (setup.id === state.meta.activeSetupId && oldName !== setup.name){
          activeSetup.value = setup.id;
        }
        renderShotsTable();
        renderPlan();
        saveMeta();
        return;
      }

      if (kind === "shot"){
        const setupId = t.dataset.setup;
        const shotId = t.dataset.id;
        const found = findShot(setupId, shotId);
        if (!found) return;

        const { setup, shot } = found;
        const k = t.dataset.k;
        const oldLabel = shot.label;

        shot[k] = t.value;

        // auto-calc with HI when editing IFS/ELEV
        const H = parseNumber(setup.hi);
        if (Number.isFinite(H) && (k === "ifs" || k === "elev")){
          const I = parseNumber(shot.ifs);
          const E = parseNumber(shot.elev);

          if (Number.isFinite(E) && !Number.isFinite(I) && String(shot.ifs||"").trim()===""){
            const autoI = computeIFS(H, E);
            if (Number.isFinite(autoI)) shot.ifs = String(autoI);
          } else if (Number.isFinite(I) && !Number.isFinite(E) && String(shot.elev||"").trim()===""){
            const autoE = computeElev(H, I);
            if (Number.isFinite(autoE)) shot.elev = String(autoE);
          }
        }

        if (k === "label"){
          const newLabel = normalizeLabel(shot.label);
          if (newLabel && newLabel !== oldLabel){
            // if duplicate, revert
            const exists = shotByLabel(newLabel);
            if (exists && exists.shot.id !== shot.id){
              shot.label = oldLabel;
              t.value = oldLabel;
              alert("That point label already exists.");
              return;
            }
            shot.label = newLabel;
            syncMarkerLabel(oldLabel, newLabel);
          }
        }

        renderShotsTable();
        renderSlopes();
        renderPlan();
        saveMeta();
      }
    });

    // photos
    photoInput.addEventListener("change", async (e) => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;
      try{ await addPhotos(files); }
      catch(err){ alert("Could not add photos. Try fewer photos or smaller sizes."); }
      finally{ photoInput.value = ""; }
    });

    photoRow.addEventListener("click", (e) => {
      const removeBtn = e.target.closest("button[data-photo-remove]");
      if (removeBtn){
        removePhoto(removeBtn.dataset.photoRemove);
        return;
      }
      const chip = e.target.closest("[data-photo-chip]");
      if (chip){
        setPhotoCaption(chip.dataset.photoId, chip.dataset.photoChip);
      }
    });

    btnClearPhotos.addEventListener("click", async () => {
      if (!state.sitePhotos.length) return;
      if (!confirm("Clear all site photos?")) return;
      for (const p of state.sitePhotos) await idbDel(p.key);
      state.sitePhotos = [];
      await renderPhotos();
      saveMeta();
      toast("Photos cleared");
    });

    // plot plan upload
    planInput.addEventListener("change", async (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      try{ await setPlotPlanFromFile(f); }
      catch(err){ alert("Could not process that file. Try a smaller PDF or export it flattened."); }
      finally{ planInput.value = ""; }
    });

    btnClearPlan.addEventListener("click", async () => {
      if (!state.plan) return;
      if (!confirm("Remove the attached plot plan?")) return;

      if (state.plan?.key) await idbDel(state.plan.key);
      state.plan = null;
      state.markers = [];
      state.ui.slopePick = null;
      await renderPlan();
      saveMeta();
      toast("Removed");
    });

    btnClearMarkers.addEventListener("click", async () => {
      if (!state.markers.length) return;
      if (!confirm("Clear all points from the plot plan?")) return;
      state.markers = [];
      state.ui.slopePick = null;
      await renderPlan();
      saveMeta();
      toast("Points cleared");
    });

    btnSlopeMode.addEventListener("click", () => setSlopeMode(!state.ui.slopeMode));

    // plan interactions (add shot / edit / slope pick)
    planStage.addEventListener("click", (e) => {
      if (!state.plan) return;

      const anchor = e.target.closest(".mkAnchor");
      if (anchor){
        const point = anchor.dataset.point;

        if (state.ui.slopeMode){
          if (!state.ui.slopePick){
            state.ui.slopePick = point;
            renderPlan();
            saveMeta();
            toast(`Slope: selected ${point}, tap second point`);
            return;
          }
          if (state.ui.slopePick === point){
            state.ui.slopePick = null;
            renderPlan();
            saveMeta();
            toast("Slope: cleared");
            return;
          }

          // add a slope row with the two points, run entered in table
          const from = state.ui.slopePick;
          const to = point;
          state.ui.slopePick = null;

          state.slopeRows.push({ id: uid(), segment:`Slope ${from}-${to}`, fromLabel: from, toLabel: to, distanceM:"" });
          renderSlopes();
          renderPlan();
          saveMeta();
          toast("Slope row added, enter run");
          return;
        }

        openShotPanelEdit(anchor.dataset.id);
        return;
      }

      if (state.ui.slopeMode){
        toast("Slope Mode: tap an existing point");
        return;
      }

      // add shot at click position
      const rect = planStage.getBoundingClientRect();
      const x = (e.clientX - rect.left) / rect.width;
      const y = (e.clientY - rect.top) / rect.height;
      const xPct = clamp(x * 100, 0, 100);
      const yPct = clamp(y * 100, 0, 100);

      openShotPanelNew(xPct, yPct);
    });

    // slopes events
    slopeBody.addEventListener("input", (e) => {
      const t = e.target;
      if (!t?.dataset?.id) return;
      if (t.dataset.type !== "slope") return;

      const row = state.slopeRows.find(r => r.id === t.dataset.id);
      if (!row) return;

      row[t.dataset.k] = t.value;
      renderSlopes();
      renderPlan();
      saveMeta();
    });

    slopeBody.addEventListener("change", (e) => {
      const t = e.target;
      if (!t?.dataset?.id) return;
      if (t.dataset.type !== "slope") return;

      const row = state.slopeRows.find(r => r.id === t.dataset.id);
      if (!row) return;

      row[t.dataset.k] = t.value;
      renderSlopes();
      renderPlan();
      saveMeta();
    });

    btnAddSlope.addEventListener("click", () => {
      state.slopeRows.push({ id: uid(), segment:"", fromLabel:"", toLabel:"", distanceM:"" });
      renderSlopes();
      saveMeta();
    });

    btnRemoveSlopeSelected.addEventListener("click", () => {
      const ids = new Set(Array.from(document.querySelectorAll(".slopeSel:checked")).map(x => x.dataset.id));
      state.slopeRows = state.slopeRows.filter(r => !ids.has(r.id));
      renderSlopes();
      renderPlan();
      saveMeta();
      toast("Removed");
    });

    window.addEventListener("resize", () => {
      if (!state.plan) return;
      renderPlan();
    });

    // ---------------- Init ----------------
    function initDefaults(){
      if (!state.meta.jobDate) state.meta.jobDate = todayISO();
      if (!Array.isArray(state.noteChecks) || state.noteChecks.length !== NOTE_CHECKS.length){
        state.noteChecks = NOTE_CHECKS.map(() => false);
      }
      if (!state.setups.length){
        // default one setup like RMOW
        const s = { id: uid(), name: "RMOW", bs:"", hi:"", fs:"", ifs:"", elev:"", shots: [] };
        state.setups.push(s);
        state.meta.activeSetupId = s.id;
      }
      if (!state.meta.activeSetupId || !state.setups.find(s => s.id === state.meta.activeSetupId)){
        state.meta.activeSetupId = state.setups[0].id;
      }
      state.meta.nextPoint = Math.max(1, getMaxNumericPoint() + 1);
    }

    function syncMetaToUI(){
      areaSelect.value = state.meta.area || "calgary";
      jobNo.value = state.meta.jobNo || "";
      jobDate.value = state.meta.jobDate || "";
      community.value = state.meta.community || "";
      address.value = state.meta.address || "";
      lotBlockPlan.value = state.meta.lotBlockPlan || "";
      crewChief.value = state.meta.crewChief || "";
      officeSummary.value = state.meta.officeSummary || "";
      setSlopeMode(!!state.ui.slopeMode);
    }

    async function boot(){
      loadMeta();
      initDefaults();
      syncMetaToUI();
      renderTolerance();
      renderNotes();
      renderActiveSetupSelect();
      renderShotsTable();
      renderSlopes();
      await renderPhotos();
      await renderPlan();
      renderSummary();
      saveMeta();
    }

    boot();
  </script>
</body>
</html>

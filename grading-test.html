<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VistaGeomatics – Grading Check</title>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Montserrat:wght@400;700&display=swap" rel="stylesheet" />

  <!-- PDF Export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

  <!-- PDF Upload Preview -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.min.js"></script>

  <style>
    :root{
      --vista-blue:#165f7d;
      --vista-blue-light:#2a7fa3;
      --vista-blue-dark:#0b3045;

      --pass-blue:#1f9cf0;  /* standard blue */
      --fail-red:#ef4444;

      --bg-body:#eef3f9;
      --bg-card:#ffffff;
      --border-soft:#d6e2f0;

      --text-main:#101827;
      --text-muted:#5b6777;

      --ok:#15803d;
      --bad:#b91c1c;

      --shadow: 0 10px 30px rgba(2, 10, 20, 0.08);
      --radius: 16px;
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:"Inter", sans-serif;
      background: radial-gradient(circle at top, #f4fbff 0%, var(--bg-body) 55%, #e9f1fb 100%);
      color:var(--text-main);
    }
    .wrap{ max-width: 1180px; margin: 20px auto 60px; padding: 0 16px; }

    .topbar{
      background: linear-gradient(135deg, var(--vista-blue-dark), var(--vista-blue));
      color:#fff;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .topbar-inner{
      display:flex;
      align-items:center;
      gap:16px;
      padding: 16px 18px;
      flex-wrap:wrap;
    }
    .logo{
      width: 54px; height: 54px; border-radius: 12px;
      background: rgba(255,255,255,0.12);
      display:flex; align-items:center; justify-content:center;
      overflow:hidden; flex: 0 0 auto;
    }
    .logo img{ width: 100%; height: 100%; object-fit: contain; padding: 8px; }
    .brand{ flex:1 1 auto; min-width: 220px; }
    .brand .title{
      font-family:"Montserrat", sans-serif;
      font-weight:700; letter-spacing:0.5px;
      font-size: 18px; margin:0; line-height:1.2;
    }
    .brand .subtitle{ margin:4px 0 0; opacity:0.9; font-size: 13px; }

    .pill{
      display:flex; gap:10px; align-items:center;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.22);
      padding:10px 12px; border-radius: 999px;
      flex: 0 0 auto; white-space: nowrap;
    }
    .pill b{ font-weight:700; }

    .grid{
      display:grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 16px;
      margin-top: 16px;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns:1fr; }
      .pill{ width:100%; justify-content:space-between; }
    }

    .card{
      background: var(--bg-card);
      border: 1px solid var(--border-soft);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .card-h{
      padding: 14px 16px;
      border-bottom: 1px solid var(--border-soft);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      background: linear-gradient(180deg, #ffffff, #fbfdff);
      flex-wrap: wrap;
    }
    .card-h h2{ margin:0; font-size: 14px; letter-spacing:0.2px; }
    .card-b{ padding: 14px 16px 16px; }

    .formgrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 620px){ .formgrid{ grid-template-columns:1fr; } }

    label{ display:block; font-size: 12px; color: var(--text-muted); margin-bottom: 6px; }

    /* Semi-transparent inputs */
    input, select, textarea{
      width:100%;
      border: 1px solid var(--border-soft);
      border-radius: 12px;
      padding: 10px 10px;
      font-size: 14px;
      outline:none;
      background: rgba(255,255,255,0.55);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      color: var(--text-main);
    }
    textarea{ min-height: 92px; resize: vertical; }

    .btnbar{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }
    .btn{
      appearance:none;
      border: 1px solid rgba(255,255,255,0.0);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight:600;
      cursor:pointer;
      transition: transform 0.05s ease, opacity 0.15s ease, background 0.15s ease;
      user-select:none;
      white-space: nowrap;
    }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ background: linear-gradient(135deg, var(--vista-blue), var(--vista-blue-light)); color:#fff; }
    .btn.ghost{ background: #f4f8fc; border: 1px solid var(--border-soft); color: var(--text-main); }
    .btn.danger{ background: #fff1f2; border: 1px solid #fecdd3; color: var(--bad); }
    .btn:disabled{ opacity:0.65; cursor:not-allowed; }

    .hint{ font-size: 12px; color: var(--text-muted); margin-top: 8px; line-height: 1.35; }

    table{
      width:100%;
      border-collapse: separate;
      border-spacing: 0;
      overflow:hidden;
      border: 1px solid var(--border-soft);
      border-radius: 14px;
    }
    thead th{
      text-align:left;
      font-size: 12px;
      color: var(--text-muted);
      padding: 10px 10px;
      background: #f6fafc;
      border-bottom: 1px solid var(--border-soft);
      white-space: nowrap;
    }
    tbody td{
      padding: 8px 10px;
      border-bottom: 1px solid var(--border-soft);
      vertical-align: middle;
      font-size: 14px;
    }
    tbody tr:last-child td{ border-bottom: none; }

    td .mini{
      padding: 8px 8px;
      border-radius: 10px;
      font-size: 13px;
      background: rgba(255,255,255,0.55);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
    }

    .status{
      font-weight: 800;
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      display:inline-block;
      border: 1px solid transparent;
      white-space: nowrap;
    }
    .status.ok{ color: var(--ok); background: #eaf7ee; border-color: #c7ecd2; }
    .status.bad{ color: var(--bad); background: #fff1f2; border-color: #fecdd3; }
    .status.na{ color: #475569; background: #eef2f7; border-color: #d6dee9; }

    .delta{ font-weight: 900; letter-spacing:0.1px; }
    .delta.ok{ color: var(--ok); }
    .delta.bad{ color: var(--bad); }
    .delta.na{ color:#475569; }

    .summary{
      display:flex; gap: 12px; flex-wrap:wrap;
      align-items:center; justify-content:space-between;
      margin-top: 10px;
      padding: 12px 12px;
      border: 1px dashed var(--border-soft);
      border-radius: 14px;
      background: #fbfdff;
    }
    .summary .k{ font-size: 12px; color: var(--text-muted); }
    .summary .v{ font-weight: 900; font-size: 14px; }

    /* Plot plan preview */
    .planPreview{
      border: 1px solid var(--border-soft);
      border-radius: 14px;
      overflow:hidden;
      background:#fff;
      box-shadow: 0 6px 16px rgba(2,10,20,0.06);
    }
    .planStage{
      position: relative;
      width: 100%;
      background:#fff;
      cursor: crosshair;
      user-select: none;
      overflow: hidden;
    }
    .planStage img{ width:100%; height:auto; display:block; }
    .planOverlay{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
    }

    /* Smaller slope label (RED) */
    .slopeLabel{
      font-family:"Inter", sans-serif;
      font-weight: 900;
      font-size: 8px;
      fill: rgba(239,68,68,0.98);
      paint-order: stroke;
      stroke: rgba(0,0,0,0.55);
      stroke-width: 2px;
      stroke-linejoin: round;
    }

    /* ===== Updated markers =====
      - point number pinned EXACTLY where user clicks
      - elevation tag sits right beside point number (can nudge to avoid overlap)
    */
    .mkAnchor{
      position:absolute;
      transform: translate(-50%, -50%);
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.85);
      background: rgba(22,95,125,0.25);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      box-shadow: 0 3px 8px rgba(2,10,20,0.12);
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:auto;
      cursor:pointer;
    }
    .mkAnchor span{
      font-size: 7px;
      font-weight: 900;
      color:#ffffff;
      line-height: 1;
    }

    .mkElev{
      position:absolute;
      transform: translate(0, -50%); /* left edge anchored, vertically centered */
      padding: 2px 4px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.85);
      background: rgba(22,95,125,0.18);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
      box-shadow: 0 3px 8px rgba(2,10,20,0.10);
      pointer-events:none;
      white-space: nowrap;
      text-align:center;
    }
    .mkElev .el{
      font-size: 7px;
      font-weight: 900;
      line-height: 1.05;
    }
    .mkElev .el.pass{ color: var(--pass-blue); }
    .mkElev .el.fail{ color: var(--fail-red); }
    .mkElev .el.na{ color: rgba(255,255,255,0.92); }

    .planMeta{
      padding: 10px 12px;
      border-top: 1px solid var(--border-soft);
      background:#fafcff;
      font-size:12px;
      color:#334155;
      display:flex;
      gap:10px;
      justify-content:space-between;
      align-items:center;
      flex-wrap:wrap;
    }

    .inlineToggle{
      display:flex;
      gap:8px;
      align-items:center;
      font-size:12px;
      color: var(--text-muted);
      padding: 8px 10px;
      border: 1px solid var(--border-soft);
      border-radius: 12px;
      background:#fbfdff;
    }
    .inlineToggle input{ width:auto; }

    /* Export host (hidden) */
    #exportHost{
      position: fixed;
      left: -99999px;
      top: 0;
      width: 816px;
      background: #fff;
      color:#101827;
    }
    .report{ padding: 18px 18px 22px; font-family:"Inter", sans-serif; }
    .reportHeader{
      display:flex; gap:12px; align-items:center;
      border-bottom: 2px solid #e5edf7;
      padding-bottom: 12px; margin-bottom: 12px;
    }
    .reportLogo{
      width: 52px; height: 52px; border-radius: 12px;
      border: 1px solid #e5edf7;
      display:flex; align-items:center; justify-content:center;
      overflow:hidden; background:#fff;
    }
    .reportLogo img{ width:100%; height:100%; object-fit:contain; padding:8px; }
    .reportTitle{
      font-family:"Montserrat", sans-serif;
      font-weight:700; letter-spacing:0.5px;
      margin:0; font-size: 16px; color:#0b3045;
    }
    .reportSub{ margin:4px 0 0; font-size: 12px; color:#475569; }

    .reportMeta{
      display:grid; grid-template-columns: 1fr 1fr;
      gap: 8px 12px; margin: 10px 0 14px;
      font-size: 12px; color:#334155;
    }
    .reportMeta b{ color:#0b3045; }

    .reportSectionTitle{
      font-family:"Montserrat", sans-serif;
      font-weight:700; font-size: 13px;
      color:#0b3045; margin: 14px 0 8px;
    }

    .reportTable{
      width:100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    .reportTable th, .reportTable td{
      border: 1px solid #d6dee9;
      padding: 6px 6px;
      vertical-align: top;
    }
    .reportTable th{
      background:#f6fafc;
      color:#334155;
      font-weight:700;
      text-align:left;
      white-space: nowrap;
    }

    .pillSmall{
      display:inline-block;
      padding: 3px 8px;
      border-radius: 999px;
      font-size: 10px;
      font-weight: 900;
      border: 1px solid #d6dee9;
      background:#eef2f7;
      color:#334155;
      white-space:nowrap;
    }
    .pillSmall.ok{ background:#eaf7ee; border-color:#c7ecd2; color:#15803d; }
    .pillSmall.bad{ background:#fff1f2; border-color:#fecdd3; color:#b91c1c; }

    .pageBreak{ page-break-before: always; }

    .planPrintWrap{
      border:1px solid #d6dee9;
      border-radius:12px;
      overflow:hidden;
    }
    .planPrintStage{ position: relative; overflow:hidden; }
    .planPrintStage img{ width:100%; height:auto; display:block; }
    .planPrintOverlay{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
    }

    /* Print markers: number pinned + elevation beside */
    .mkAnchorPrint{
      position:absolute;
      transform: translate(-50%, -50%);
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.85);
      background: rgba(22,95,125,0.25);
      box-shadow: 0 3px 8px rgba(2,10,20,0.12);
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .mkAnchorPrint span{
      font-size: 7px;
      font-weight: 900;
      color:#ffffff;
      line-height: 1;
    }

    .mkElevPrint{
      position:absolute;
      transform: translate(0, -50%);
      padding: 2px 4px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.85);
      background: rgba(22,95,125,0.18);
      box-shadow: 0 3px 8px rgba(2,10,20,0.10);
      white-space: nowrap;
      text-align:center;
    }
    .mkElevPrint .el{
      font-size: 7px;
      font-weight: 900;
      line-height: 1.05;
    }
    .mkElevPrint .el.pass{ color: var(--pass-blue); }
    .mkElevPrint .el.fail{ color: var(--fail-red); }
    .mkElevPrint .el.na{ color: rgba(255,255,255,0.92); }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="topbar-inner">
        <div class="logo" title="Vista Geomatics">
          <img src="vista-geomatics.png" alt="Vista Geomatics Logo" />
        </div>

        <div class="brand">
          <p class="title">VISTA GEOMATICS</p>
          <p class="subtitle">FIELD GRADING CHECK</p>
        </div>

        <div class="pill">
          <span><b>Area</b></span>
          <select id="areaSelect" style="width:auto; background: rgba(255,255,255,0.95); color:#0b3045; border:none; border-radius:999px; padding:8px 10px;">
            <option value="calgary">Calgary</option>
            <option value="chestermere">Chestermere</option>
            <option value="airdrie">Airdrie</option>
          </select>
        </div>

        <div class="pill">
          <span><b>Tolerance</b></span>
          <span id="tolLabel">±15 cm</span>
        </div>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <div class="card-h">
          <h2>Job Details</h2>
          <div class="btnbar">
            <button class="btn ghost" id="btnSave" type="button">Save</button>
            <button class="btn ghost" id="btnReset" type="button">Clear</button>
            <button class="btn primary" id="btnPDF" type="button">Export PDF</button>
            <button class="btn primary" id="btnShare" type="button">Share PDF</button>
          </div>
        </div>
        <div class="card-b">
          <div class="formgrid">
            <div>
              <label>Job Number</label>
              <input id="jobNo" placeholder="e.g., 25-0123" autocomplete="off" />
            </div>
            <div>
              <label>Date</label>
              <input id="jobDate" type="date" />
            </div>
            <div>
              <label>Community / Subdivision</label>
              <input id="community" placeholder="e.g., Cornerstone" autocomplete="off" />
            </div>
            <div>
              <label>Address</label>
              <input id="address" placeholder="e.g., 2053–2055 Cornerstone Blvd NE" autocomplete="off" />
            </div>
            <div>
              <label>Lot / Block / Plan</label>
              <input id="lotBlockPlan" placeholder="e.g., Lot 12, Block 3, Plan ____" autocomplete="off" />
            </div>
            <div>
              <label>Crew Chief</label>
              <input id="crewChief" placeholder="Name" autocomplete="off" />
            </div>
          </div>

          <div class="summary" style="margin-top:14px;">
            <div><div class="k">Points Checked</div><div class="v" id="sumPoints">0</div></div>
            <div><div class="k">Fails</div><div class="v" id="sumFails">0</div></div>
            <div><div class="k">Worst Δ (cm)</div><div class="v" id="sumWorst">—</div></div>
          </div>

          <div class="hint">
            Saves on this device. If plot plan PDFs are large, upload a screenshot image or Print to PDF (flatten) first.
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-h">
          <h2>Office Summary</h2>
          <div class="btnbar">
            <button class="btn ghost" id="btnGenSummary" type="button">Generate</button>
            <button class="btn primary" id="btnCopySummary" type="button">Copy</button>
          </div>
        </div>
        <div class="card-b">
          <label>Auto-generated summary for office & drafters</label>
          <textarea id="officeSummary" placeholder="Click Generate to build a consistent summary..."></textarea>
          <div class="hint">
            Includes tolerance, pass/fails, worst deltas, and slope values.
          </div>
        </div>
      </div>

      <div class="card" style="grid-column:1/-1;">
        <div class="card-h">
          <h2>Marked Up Plot Plan (Image or PDF)</h2>
          <div class="btnbar">
            <label class="btn ghost" style="cursor:pointer;">
              Upload Plot Plan
              <input id="planInput" type="file" accept="image/*,application/pdf" style="display:none;">
            </label>
            <button class="btn danger" id="btnClearPlan" type="button">Remove</button>
            <button class="btn ghost" id="btnClearMarkers" type="button">Clear Points</button>
          </div>
        </div>
        <div class="card-b">
          <div class="hint" style="margin-top:0;">
            Click to place a point. The point number is placed <b>exactly where you click</b>, and the elevation is shown <b>right beside</b> it.
            Elevation tags auto-nudge to avoid overlaps, but the point number never moves.
          </div>

          <div id="planEmpty" style="margin-top:12px; padding:14px; border:1px dashed var(--border-soft); border-radius:14px; background:#fbfdff; color:var(--text-muted);">
            No plot plan attached yet.
          </div>

          <div id="planWrap" style="margin-top:12px; display:none;">
            <div class="planPreview">
              <div class="planStage" id="planStage" title="Click on the plan to add a point">
                <img id="planImg" alt="Marked up plot plan preview" />
                <svg class="planOverlay" id="planOverlay" viewBox="0 0 1000 1000" preserveAspectRatio="none"></svg>
              </div>
              <div class="planMeta">
                <div>
                  <b id="planName">—</b>
                  <div id="planType" style="opacity:0.85; margin-top:2px;"></div>
                </div>
                <div class="hint" style="margin:0;">
                  Tap a point number to edit/remove.
                </div>
              </div>
            </div>
          </div>

        </div>
      </div>

      <div class="card" style="grid-column: 1 / -1;">
        <div class="card-h">
          <h2>Elevation Comparison</h2>
          <div class="btnbar" style="justify-content:space-between; width:100%;">
            <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
              <div class="inlineToggle">
                <input id="numericKeypad" type="checkbox" checked />
                <span><b>Numeric keypad</b> on iPad for elevations</span>
              </div>
            </div>
            <div class="btnbar" style="justify-content:flex-end;">
              <button class="btn ghost" id="btnAddRow" type="button">Add Row</button>
              <button class="btn danger" id="btnRemoveSelected" type="button">Remove Selected</button>
            </div>
          </div>
        </div>

        <div class="card-b">
          <div class="hint" style="margin-top:0;">
            Δ (cm) = (Field − Design) × 100. Points placed on the plan also populate the table.
          </div>

          <div style="margin-top:12px; overflow:auto;">
            <table>
              <thead>
                <tr>
                  <th style="width:44px;">Sel</th>
                  <th style="min-width:180px;">Point</th>
                  <th style="min-width:150px;">Field Elev</th>
                  <th style="min-width:150px;">Design Elev</th>
                  <th style="min-width:120px;">Δ (cm)</th>
                  <th style="min-width:110px;">Status</th>
                </tr>
              </thead>
              <tbody id="elevBody"></tbody>
            </table>
          </div>
        </div>
      </div>

      <div class="card" style="grid-column: 1 / -1;">
        <div class="card-h">
          <h2>Slope Calculator (Between Points)</h2>
          <div class="btnbar">
            <button class="btn ghost" id="btnAddSlope" type="button">Add Slope Row</button>
            <button class="btn danger" id="btnRemoveSlopeSelected" type="button">Remove Selected</button>
          </div>
        </div>
        <div class="card-b">
          <div class="hint" style="margin-top:0;">
            Arrow points downhill (higher elev → lower elev). Uses Field elev when available, otherwise Design elev.
          </div>

          <div style="margin-top:12px; overflow:auto;">
            <table>
              <thead>
                <tr>
                  <th style="width:44px;">Sel</th>
                  <th style="min-width:220px;">Segment</th>
                  <th style="min-width:180px;">From</th>
                  <th style="min-width:180px;">To</th>
                  <th style="min-width:140px;">Distance (m)</th>
                  <th style="min-width:140px;">Downhill Slope %</th>
                </tr>
              </thead>
              <tbody id="slopeBody"></tbody>
            </table>
          </div>
        </div>
      </div>

    </div>
  </div>

  <div id="exportHost" aria-hidden="true"></div>

  <script>
    // PDF.js worker
    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.10.38/pdf.worker.min.js";
    }

    const STORAGE_KEY = "vista_grading_check_full_v8";
    const tolByAreaCm = { calgary: 15, chestermere: 15, airdrie: 10 };

    const state = {
      meta: { area:"calgary", jobNo:"", jobDate:"", community:"", address:"", lotBlockPlan:"", crewChief:"", officeSummary:"", nextPoint: 1 },
      plan: null,
      // marker: {id, xPct,yPct, labelXPct,labelYPct, point, fieldElev, designElev}
      markers: [],
      elevRows: [],
      slopeRows: []
    };

    // ---------- helpers ----------
    function uid(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }
    function todayISO(){
      const d = new Date();
      return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,"0")}-${String(d.getDate()).padStart(2,"0")}`;
    }
    function safeName(s){
      return String(s ?? "").trim().replace(/[\\/:*?"<>|]+/g,"").replace(/\s+/g," ").replaceAll(" ","_").slice(0,80) || "Grading_Check";
    }
    function defaultFileName(ext){
      const job = safeName(state.meta.jobNo || "Job");
      const crew = safeName(state.meta.crewChief || "Crew");
      return `${job}_${crew}_${todayISO()}.${ext}`;
    }
    function escapeHtml(s){
      return String(s ?? "")
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
        .replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }
    function parseNumber(v){
      const s = String(v ?? "").trim();
      if (!s) return null;
      const n = Number(s.replace(",", "."));
      return Number.isFinite(n) ? n : null;
    }
    function normalizeElevToMeters(v){
      const n = parseNumber(v);
      if (!Number.isFinite(n)) return null;
      return n > 1000 ? n / 100 : n;
    }
    function fmtDash(n, d=2){ return Number.isFinite(n) ? Number(n).toFixed(d) : "—"; }
    function calcDeltaCm(fieldM, designM){
      if (!Number.isFinite(fieldM) || !Number.isFinite(designM)) return null;
      return (fieldM - designM) * 100;
    }
    function passFail(deltaCmVal, tolCm){
      if (!Number.isFinite(deltaCmVal)) return "N/A";
      return Math.abs(deltaCmVal) <= tolCm ? "PASS" : "FAIL";
    }
    function markerStatusClass(fieldElev, designElev){
      const tol = tolByAreaCm[state.meta.area] ?? 15;
      const f = normalizeElevToMeters(fieldElev);
      const d = normalizeElevToMeters(designElev);
      const cm = calcDeltaCm(f,d);
      if (!Number.isFinite(cm)) return "na";
      return Math.abs(cm) <= tol ? "pass" : "fail";
    }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    // choose elevation for downhill direction: prefer field, else design
    function bestElevForPoint(pointName){
      const p = String(pointName||"").trim();
      if (!p) return null;

      const r = state.elevRows.find(x => String(x.pointName||"").trim() === p);
      const f = normalizeElevToMeters(r?.fieldElev);
      const d = normalizeElevToMeters(r?.designElev);
      if (Number.isFinite(f)) return f;
      if (Number.isFinite(d)) return d;

      const mk = state.markers.find(m => String(m.point||"").trim() === p);
      const mf = normalizeElevToMeters(mk?.fieldElev);
      const md = normalizeElevToMeters(mk?.designElev);
      if (Number.isFinite(mf)) return mf;
      if (Number.isFinite(md)) return md;

      return null;
    }

    // ---------- elements ----------
    const areaSelect = document.getElementById("areaSelect");
    const tolLabel = document.getElementById("tolLabel");
    const jobNo = document.getElementById("jobNo");
    const jobDate = document.getElementById("jobDate");
    const community = document.getElementById("community");
    const address = document.getElementById("address");
    const lotBlockPlan = document.getElementById("lotBlockPlan");
    const crewChief = document.getElementById("crewChief");

    const sumPoints = document.getElementById("sumPoints");
    const sumFails = document.getElementById("sumFails");
    const sumWorst = document.getElementById("sumWorst");

    const btnSave = document.getElementById("btnSave");
    const btnReset = document.getElementById("btnReset");
    const btnPDF = document.getElementById("btnPDF");
    const btnShare = document.getElementById("btnShare");

    const officeSummary = document.getElementById("officeSummary");
    const btnGenSummary = document.getElementById("btnGenSummary");
    const btnCopySummary = document.getElementById("btnCopySummary");

    const planInput = document.getElementById("planInput");
    const btnClearPlan = document.getElementById("btnClearPlan");
    const btnClearMarkers = document.getElementById("btnClearMarkers");
    const planWrap = document.getElementById("planWrap");
    const planEmpty = document.getElementById("planEmpty");
    const planStage = document.getElementById("planStage");
    const planOverlay = document.getElementById("planOverlay");
    const planImg = document.getElementById("planImg");
    const planName = document.getElementById("planName");
    const planType = document.getElementById("planType");

    const elevBody = document.getElementById("elevBody");
    const btnAddRow = document.getElementById("btnAddRow");
    const btnRemoveSelected = document.getElementById("btnRemoveSelected");

    const slopeBody = document.getElementById("slopeBody");
    const btnAddSlope = document.getElementById("btnAddSlope");
    const btnRemoveSlopeSelected = document.getElementById("btnRemoveSlopeSelected");

    const numericKeypad = document.getElementById("numericKeypad");
    const exportHost = document.getElementById("exportHost");

    // ---------- storage ----------
    function saveToStorage(showToast=false){
      try{
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        if (showToast){
          btnSave.textContent = "Saved";
          setTimeout(() => btnSave.textContent = "Save", 900);
        }
      }catch(e){
        alert("Save failed (storage limit). Use smaller plan images or clear points.");
      }
    }

    function loadFromStorage(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        const p = JSON.parse(raw);
        if (!p || typeof p !== "object") return false;
        state.meta = Object.assign(state.meta, p.meta || {});
        state.plan = p.plan || null;
        state.markers = Array.isArray(p.markers) ? p.markers : [];
        state.elevRows = Array.isArray(p.elevRows) ? p.elevRows : [];
        state.slopeRows = Array.isArray(p.slopeRows) ? p.slopeRows : [];
        return true;
      }catch(e){ return false; }
    }

    // ---------- tolerance + summary ----------
    function renderTolerance(){
      const tol = tolByAreaCm[state.meta.area] ?? 15;
      tolLabel.textContent = `±${tol} cm`;
    }

    function renderSummary(){
      const tol = tolByAreaCm[state.meta.area] ?? 15;
      let pointsChecked = 0, fails = 0;
      let worstAbs = null, worstSigned = null;

      for (const r of state.elevRows){
        const f = normalizeElevToMeters(r.fieldElev);
        const d = normalizeElevToMeters(r.designElev);
        const cm = calcDeltaCm(f,d);
        if (!Number.isFinite(cm)) continue;
        pointsChecked++;
        if (Math.abs(cm) > tol) fails++;
        const abs = Math.abs(cm);
        if (worstAbs === null || abs > worstAbs){
          worstAbs = abs;
          worstSigned = cm;
        }
      }
      sumPoints.textContent = String(pointsChecked);
      sumFails.textContent = String(fails);
      sumWorst.textContent = worstSigned === null ? "—" : fmtDash(worstSigned, 1);
    }

    // ---------- numeric keypad attrs ----------
    function numAttrs(){
      return numericKeypad.checked ? `type="number" step="any" inputmode="decimal" pattern="[0-9]*"` : `inputmode="decimal"`;
    }

    // ---------- auto point numbering ----------
    function getMaxNumericPoint(){
      let maxN = 0;
      for (const r of state.elevRows){
        const s = String(r.pointName||"").trim();
        if (/^\d+$/.test(s)) maxN = Math.max(maxN, parseInt(s,10));
      }
      for (const m of state.markers){
        const s = String(m.point||"").trim();
        if (/^\d+$/.test(s)) maxN = Math.max(maxN, parseInt(s,10));
      }
      return maxN;
    }
    function nextAutoPoint(){
      if (!Number.isFinite(state.meta.nextPoint) || state.meta.nextPoint < 1){
        state.meta.nextPoint = getMaxNumericPoint() + 1;
        if (state.meta.nextPoint < 1) state.meta.nextPoint = 1;
      }
      const n = state.meta.nextPoint;
      state.meta.nextPoint += 1;
      saveToStorage();
      return String(n);
    }

    // ---------- collision avoidance for elevation tags (point number never moves) ----------
    // These describe the *elevation tag* box, not the point number.
    const LABEL_W_PX = 36;
    const LABEL_H_PX = 14;
    const LABEL_PAD_PX = 4;

    function labelDimsPct(){
      const rect = planStage.getBoundingClientRect();
      const wPct = ((LABEL_W_PX + LABEL_PAD_PX) / Math.max(1, rect.width)) * 100;
      const hPct = ((LABEL_H_PX + LABEL_PAD_PX) / Math.max(1, rect.height)) * 100;
      return { wPct, hPct };
    }
    function boxesOverlap(a,b){ return !(a.x2 <= b.x1 || a.x1 >= b.x2 || a.y2 <= b.y1 || a.y1 >= b.y2); }

    // mkElev is positioned with translate(0,-50%) at (labelXPct,labelYPct)
    // so box is [x, x+w] and [y-h/2, y+h/2]
    function elevBox(m, wPct, hPct){
      const x1 = m.labelXPct;
      const x2 = m.labelXPct + wPct;
      const y1 = m.labelYPct - hPct/2;
      const y2 = m.labelYPct + hPct/2;
      return { x1,y1,x2,y2 };
    }

    function seedLabelPosition(m){
      // Place elevation just to the right of the point number
      m.labelXPct = (m.labelXPct ?? clamp(m.xPct + 1.0, 0, 100));
      m.labelYPct = (m.labelYPct ?? m.yPct);
    }

    function resolveLabelCollisions(){
      if (!state.plan || state.markers.length < 2) return;
      const { wPct, hPct } = labelDimsPct();
      const maxIter = 220;

      // First, clamp to safe bounds so tag stays inside plan
      for (const m of state.markers){
        m.labelXPct = clamp(m.labelXPct, 0, 100 - wPct);
        m.labelYPct = clamp(m.labelYPct, hPct/2, 100 - hPct/2);
      }

      for (let iter=0; iter<maxIter; iter++){
        let moved = false;

        for (let i=0; i<state.markers.length; i++){
          for (let j=i+1; j<state.markers.length; j++){
            const a = state.markers[i], b = state.markers[j];
            const A = elevBox(a,wPct,hPct);
            const B = elevBox(b,wPct,hPct);
            if (!boxesOverlap(A,B)) continue;

            moved = true;

            // push apart mainly in Y, a bit in X, but keep near the anchor
            const dy = (a.labelYPct - b.labelYPct) || (Math.random()-0.5);
            const dx = (a.labelXPct - b.labelXPct) || (Math.random()-0.5);

            const stepY = (hPct * 0.22) * Math.sign(dy);
            const stepX = (wPct * 0.10) * Math.sign(dx);

            a.labelYPct = clamp(a.labelYPct + stepY, hPct/2, 100 - hPct/2);
            b.labelYPct = clamp(b.labelYPct - stepY, hPct/2, 100 - hPct/2);

            a.labelXPct = clamp(a.labelXPct + stepX, 0, 100 - wPct);
            b.labelXPct = clamp(b.labelXPct - stepX, 0, 100 - wPct);
          }
        }

        if (!moved) break;
      }
    }

    // ---------- slope overlay ----------
    function clearPlanOverlay(){ planOverlay.innerHTML = ""; }
    function pctToOverlay(xPct, yPct){ return { x:(xPct/100)*1000, y:(yPct/100)*1000 }; }

    function slopePercentAbs(elevHighM, elevLowM, runM){
      if (!Number.isFinite(elevHighM) || !Number.isFinite(elevLowM) || !Number.isFinite(runM) || runM <= 0) return null;
      return Math.abs(((elevLowM - elevHighM) / runM) * 100);
    }

    function markerByPoint(pointName){
      const p = String(pointName||"").trim();
      return state.markers.find(m => String(m.point||"").trim() === p) || null;
    }

    function drawPlanArrows(){
      clearPlanOverlay();
      if (!state.plan) return;

      // smaller red arrowhead
      const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
      const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
      marker.setAttribute("id", "arrowHead");
      marker.setAttribute("markerWidth", "7");
      marker.setAttribute("markerHeight", "7");
      marker.setAttribute("refX", "5.5");
      marker.setAttribute("refY", "2.5");
      marker.setAttribute("orient", "auto");
      marker.setAttribute("markerUnits", "strokeWidth");

      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", "M0,0 L7,2.5 L0,5 Z");
      path.setAttribute("fill", "rgba(239,68,68,0.92)");
      marker.appendChild(path);
      defs.appendChild(marker);
      planOverlay.appendChild(defs);

      for (const sr of state.slopeRows){
        const fromP = (sr.fromPoint||"").trim();
        const toP   = (sr.toPoint||"").trim();
        if (!fromP || !toP) continue;

        const mkFrom = markerByPoint(fromP);
        const mkTo   = markerByPoint(toP);
        if (!mkFrom || !mkTo) continue;

        const runM = parseNumber(sr.distanceM);
        if (!Number.isFinite(runM) || runM <= 0) continue;

        // Determine downhill direction using best elevations
        const elevFrom = bestElevForPoint(fromP);
        const elevTo   = bestElevForPoint(toP);
        if (!Number.isFinite(elevFrom) || !Number.isFinite(elevTo)) continue;

        // Arrow always points from HIGH -> LOW
        const highIsFrom = elevFrom >= elevTo;
        const mkHigh = highIsFrom ? mkFrom : mkTo;
        const mkLow  = highIsFrom ? mkTo   : mkFrom;

        const slopeAbs = slopePercentAbs(Math.max(elevFrom,elevTo), Math.min(elevFrom,elevTo), runM);
        if (!Number.isFinite(slopeAbs)) continue;

        const A = pctToOverlay(mkHigh.xPct, mkHigh.yPct);
        const B = pctToOverlay(mkLow.xPct,  mkLow.yPct);

        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", A.x);
        line.setAttribute("y1", A.y);
        line.setAttribute("x2", B.x);
        line.setAttribute("y2", B.y);
        line.setAttribute("stroke", "rgba(239,68,68,0.88)");
        line.setAttribute("stroke-width", "2");
        line.setAttribute("stroke-linecap", "round");
        line.setAttribute("marker-end", "url(#arrowHead)");
        planOverlay.appendChild(line);

        // smaller label at midpoint
        const mx = (A.x + B.x) / 2;
        const my = (A.y + B.y) / 2;

        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", mx);
        text.setAttribute("y", my);
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("dominant-baseline", "central");
        text.setAttribute("class", "slopeLabel");
        text.textContent = `${fmtDash(slopeAbs, 2)}%`;
        planOverlay.appendChild(text);
      }
    }

    // ---------- plan render ----------
    function renderPlan(){
      planStage.querySelectorAll(".mkAnchor, .mkElev").forEach(n => n.remove());
      clearPlanOverlay();

      if (!state.plan){
        planWrap.style.display = "none";
        planEmpty.style.display = "block";
        renderSummary();
        return;
      }

      planWrap.style.display = "block";
      planEmpty.style.display = "none";

      planImg.src = state.plan.dataUrl;
      planName.textContent = state.plan.name || "Plot plan";
      planType.textContent = state.plan.kind === "pdf" ? "PDF (page 1 rendered)" : "Image";

      for (const m of state.markers) seedLabelPosition(m);
      resolveLabelCollisions();

      for (const m of state.markers){
        const cls = markerStatusClass(m.fieldElev, m.designElev);

        // Point number pinned EXACT click
        const a = document.createElement("div");
        a.className = "mkAnchor";
        a.style.left = m.xPct + "%";
        a.style.top  = m.yPct + "%";
        a.dataset.id = m.id;
        a.title = `Point ${m.point} (tap to edit/remove)`;
        a.innerHTML = `<span>${escapeHtml(m.point)}</span>`;
        planStage.appendChild(a);

        // Elevation tag beside it (allowed to nudge)
        const e = document.createElement("div");
        e.className = "mkElev";
        e.style.left = m.labelXPct + "%";
        e.style.top  = m.labelYPct + "%";
        e.innerHTML = `<div class="el ${cls}">${escapeHtml(m.fieldElev || "")}</div>`;
        planStage.appendChild(e);
      }

      drawPlanArrows();
      renderSummary();
      saveToStorage();
    }

    // ---------- elevations table ----------
    function renderElevations(){
      const tol = tolByAreaCm[state.meta.area] ?? 15;
      elevBody.innerHTML = "";

      for (const r of state.elevRows){
        const f = normalizeElevToMeters(r.fieldElev);
        const d = normalizeElevToMeters(r.designElev);
        const cm = calcDeltaCm(f,d);
        const status = passFail(cm, tol);
        const deltaClass = status==="PASS" ? "ok" : (status==="FAIL" ? "bad" : "na");
        const statusClass = status==="PASS" ? "ok" : (status==="FAIL" ? "bad" : "na");

        const tr = document.createElement("tr");
        tr.dataset.rowId = r.id;
        tr.innerHTML = `
          <td><input type="checkbox" class="rowSel" data-id="${r.id}"></td>
          <td><input class="mini" data-type="elev" data-k="pointName" data-id="${r.id}" value="${escapeHtml(r.pointName||"")}" placeholder="Point" /></td>
          <td><input class="mini" ${numAttrs()} data-type="elev" data-k="fieldElev" data-id="${r.id}" value="${escapeHtml(r.fieldElev||"")}" placeholder="Field" /></td>
          <td><input class="mini" ${numAttrs()} data-type="elev" data-k="designElev" data-id="${r.id}" value="${escapeHtml(r.designElev||"")}" placeholder="Design" /></td>
          <td><span class="delta ${deltaClass}" data-role="delta">${Number.isFinite(cm) ? fmtDash(cm,1) : "—"}</span></td>
          <td><span class="status ${statusClass}" data-role="status">${status}</span></td>
        `;
        elevBody.appendChild(tr);
      }

      renderSummary();
      renderPlan(); // keep plan colors + arrows in sync
    }

    function updateComputedRow(rowId){
      const tol = tolByAreaCm[state.meta.area] ?? 15;
      const r = state.elevRows.find(x => x.id === rowId);
      const tr = elevBody.querySelector(`tr[data-row-id="${CSS.escape(rowId)}"]`);
      if (!r || !tr) return;

      const f = normalizeElevToMeters(r.fieldElev);
      const d = normalizeElevToMeters(r.designElev);
      const cm = calcDeltaCm(f,d);
      const status = passFail(cm, tol);

      const deltaEl = tr.querySelector('[data-role="delta"]');
      const statusEl = tr.querySelector('[data-role="status"]');

      const deltaClass = status==="PASS" ? "ok" : (status==="FAIL" ? "bad" : "na");
      const statusClass = status==="PASS" ? "ok" : (status==="FAIL" ? "bad" : "na");

      if (deltaEl){
        deltaEl.textContent = Number.isFinite(cm) ? fmtDash(cm,1) : "—";
        deltaEl.className = `delta ${deltaClass}`;
      }
      if (statusEl){
        statusEl.textContent = status;
        statusEl.className = `status ${statusClass}`;
      }

      // sync marker if exists
      const p = String(r.pointName||"").trim();
      if (p){
        const mk = state.markers.find(m => String(m.point||"").trim() === p);
        if (mk){
          mk.fieldElev = r.fieldElev || mk.fieldElev;
          mk.designElev = r.designElev || mk.designElev;
        }
      }

      renderSummary();
      renderPlan();
      saveToStorage();
    }

    // ---------- slopes table ----------
    function pointNameOptions(){
      const names = state.elevRows.map(r => (r.pointName||"").trim()).filter(Boolean);
      return Array.from(new Set(names));
    }
    function selectHtml(rowId, key, current, options){
      const cur = (current||"").trim();
      const opts = options.map(n => `<option value="${escapeHtml(n)}" ${n===cur?"selected":""}>${escapeHtml(n)}</option>`).join("");
      return `<select class="mini" data-type="slope" data-k="${key}" data-id="${rowId}">
        <option value="">Select…</option>${opts}
      </select>`;
    }

    function slopePercentAbsFromPoints(fromP, toP, runM){
      const eFrom = bestElevForPoint(fromP);
      const eTo   = bestElevForPoint(toP);
      if (!Number.isFinite(eFrom) || !Number.isFinite(eTo) || !Number.isFinite(runM) || runM<=0) return null;
      const high = Math.max(eFrom,eTo);
      const low  = Math.min(eFrom,eTo);
      return slopePercentAbs(high, low, runM);
    }

    function renderSlopes(){
      const options = pointNameOptions();
      slopeBody.innerHTML = "";

      for (const r of state.slopeRows){
        const runM = parseNumber(r.distanceM);
        const sAbs = slopePercentAbsFromPoints(r.fromPoint, r.toPoint, runM);

        const tr = document.createElement("tr");
        tr.dataset.rowId = r.id;
        tr.innerHTML = `
          <td><input type="checkbox" class="slopeSel" data-id="${r.id}"></td>
          <td><input class="mini" data-type="slope" data-k="segment" data-id="${r.id}" value="${escapeHtml(r.segment||"")}" placeholder="e.g., Front swale" /></td>
          <td>${selectHtml(r.id,"fromPoint",r.fromPoint,options)}</td>
          <td>${selectHtml(r.id,"toPoint",r.toPoint,options)}</td>
          <td><input class="mini" ${numAttrs()} data-type="slope" data-k="distanceM" data-id="${r.id}" value="${escapeHtml(r.distanceM||"")}" placeholder="Run (m)" /></td>
          <td><span class="delta na">${Number.isFinite(sAbs) ? fmtDash(sAbs,2) : "—"}</span></td>
        `;
        slopeBody.appendChild(tr);
      }

      drawPlanArrows();
      saveToStorage();
    }

    // ---------- plot plan upload ----------
    async function fileToArrayBuffer(file){
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onerror = () => reject(new Error("Read failed"));
        fr.onload = () => resolve(fr.result);
        fr.readAsArrayBuffer(file);
      });
    }

    function compressImageToDataUrl(file, maxDim=1800, quality=0.88){
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onerror = () => reject(new Error("File read failed"));
        fr.onload = () => {
          const img = new Image();
          img.onload = () => {
            const w = img.width, h = img.height;
            const scale = Math.min(1, maxDim / Math.max(w, h));
            const cw = Math.round(w * scale);
            const ch = Math.round(h * scale);
            const canvas = document.createElement("canvas");
            canvas.width = cw; canvas.height = ch;
            const ctx = canvas.getContext("2d", { alpha:false });
            ctx.drawImage(img, 0, 0, cw, ch);
            resolve(canvas.toDataURL("image/jpeg", quality));
          };
          img.onerror = () => reject(new Error("Image load failed"));
          img.src = fr.result;
        };
        fr.readAsDataURL(file);
      });
    }

    async function renderPdfFirstPageToDataUrl(file, maxWidth = 1200) {
      if (!window.pdfjsLib) throw new Error("PDF.js did not load.");
      const ab = await fileToArrayBuffer(file);
      const loadingTask = pdfjsLib.getDocument({ data: ab, disableAutoFetch:true, disableStream:true });
      const pdf = await loadingTask.promise;
      const page = await pdf.getPage(1);

      const viewport1 = page.getViewport({ scale: 1 });
      const scale = Math.min(2.0, maxWidth / viewport1.width);
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d", { alpha:false });
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      await page.render({ canvasContext: ctx, viewport }).promise;
      return canvas.toDataURL("image/jpeg", 0.85);
    }

    async function setPlotPlanFromFile(file){
      const isPdf = file.type === "application/pdf" || (file.name||"").toLowerCase().endsWith(".pdf");
      let dataUrl = "", kind = "image";

      if (isPdf){
        kind = "pdf";
        dataUrl = await renderPdfFirstPageToDataUrl(file, 1200);
      } else if (file.type.startsWith("image/")){
        kind = "image";
        dataUrl = await compressImageToDataUrl(file, 1800, 0.88);
      } else {
        throw new Error("Unsupported file type");
      }

      state.plan = { name: file.name || "plot-plan", kind, dataUrl };
      state.markers = [];
      state.meta.nextPoint = Math.max(1, getMaxNumericPoint() + 1);
      renderPlan();
      saveToStorage();
    }

    // ---------- point placement ----------
    function promptFieldDesign(point){
      const f = prompt(`Field elevation for Point ${point} (e.g., 92.21 or 9221):`, "");
      if (f === null) return null;
      const fieldElev = String(f).trim();
      if (!fieldElev){ alert("Field elevation is required."); return null; }

      const d = prompt(`Design elevation for Point ${point} (Plot Plan):`, "");
      if (d === null) return null;
      const designElev = String(d).trim();
      if (!designElev){ alert("Design elevation is required."); return null; }

      return { fieldElev, designElev };
    }

    function upsertElevRow(point, fieldElev, designElev){
      const p = String(point||"").trim();
      if (!p) return;

      let r = state.elevRows.find(x => String(x.pointName||"").trim() === p);
      if (!r){
        r = { id: uid(), pointName: p, fieldElev:"", designElev:"" };
        state.elevRows.push(r);
      }
      r.fieldElev = String(fieldElev||"").trim();
      r.designElev = String(designElev||"").trim();
    }

    function addPointAtClick(evt){
      if (!state.plan) return;

      const rect = planStage.getBoundingClientRect();
      const x = (evt.clientX - rect.left) / rect.width;
      const y = (evt.clientY - rect.top) / rect.height;
      const xPct = clamp(x * 100, 0, 100);
      const yPct = clamp(y * 100, 0, 100);

      const point = nextAutoPoint();
      const data = promptFieldDesign(point);
      if (!data){
        state.meta.nextPoint = Math.max(1, (state.meta.nextPoint||2) - 1);
        saveToStorage();
        return;
      }

      const mk = {
        id: uid(),
        xPct, yPct, // anchor EXACT click
        labelXPct: xPct + 1.0, // elevation tag to the right by default
        labelYPct: yPct,
        point,
        fieldElev: data.fieldElev,
        designElev: data.designElev
      };

      state.markers.push(mk);
      upsertElevRow(point, data.fieldElev, data.designElev);

      renderElevations();
      renderSlopes();
      renderPlan();
      saveToStorage();
    }

    function editOrRemovePoint(markerId){
      const mk = state.markers.find(m => m.id === markerId);
      if (!mk) return;

      const action = prompt(`Point ${mk.point}: type "edit" to change elevations, or "remove" to delete.`, "edit");
      if (action === null) return;

      const a = action.trim().toLowerCase();
      if (a === "remove"){
        state.markers = state.markers.filter(m => m.id !== markerId);
        state.meta.nextPoint = Math.max(1, getMaxNumericPoint() + 1);
        renderPlan();
        saveToStorage();
        return;
      }

      if (a === "edit"){
        const f = prompt(`Field elevation for Point ${mk.point}:`, mk.fieldElev || "");
        if (f === null) return;
        const d = prompt(`Design elevation for Point ${mk.point}:`, mk.designElev || "");
        if (d === null) return;

        mk.fieldElev = String(f).trim();
        mk.designElev = String(d).trim();
        upsertElevRow(mk.point, mk.fieldElev, mk.designElev);

        renderElevations();
        renderSlopes();
        renderPlan();
        saveToStorage();
      }
    }

    // ---------- PDF export / share ----------
    function waitImagesLoaded(container){
      const imgs = Array.from(container.querySelectorAll("img"));
      if (!imgs.length) return Promise.resolve();
      return Promise.all(imgs.map(img => {
        if (img.complete && img.naturalWidth > 0) return Promise.resolve();
        return new Promise(res => {
          const done = () => res();
          img.addEventListener("load", done, { once:true });
          img.addEventListener("error", done, { once:true });
        });
      })).then(() => undefined);
    }

    function buildReportElement(){
      exportHost.innerHTML = "";
      const tol = tolByAreaCm[state.meta.area] ?? 15;

      const root = document.createElement("div");
      root.className = "report";

      root.innerHTML = `
        <div class="reportHeader">
          <div class="reportLogo"><img src="vista-geomatics.png" alt="Logo"/></div>
          <div>
            <p class="reportTitle">VISTA GEOMATICS, Grading Check Report</p>
            <p class="reportSub">Tolerance: ±${tol} cm</p>
          </div>
        </div>

        <div class="reportMeta">
          <div><b>Job Number:</b> ${escapeHtml(state.meta.jobNo||"")}</div>
          <div><b>Date:</b> ${escapeHtml(state.meta.jobDate||"")}</div>
          <div><b>Community:</b> ${escapeHtml(state.meta.community||"")}</div>
          <div><b>Address:</b> ${escapeHtml(state.meta.address||"")}</div>
          <div><b>Lot/Block/Plan:</b> ${escapeHtml(state.meta.lotBlockPlan||"")}</div>
          <div><b>Crew Chief:</b> ${escapeHtml(state.meta.crewChief||"")}</div>
        </div>

        <div class="reportSectionTitle">Office Summary</div>
        <div style="border:1px solid #d6dee9; border-radius:12px; padding:10px; font-size:11px; color:#334155; white-space:pre-wrap; background:#fbfdff;">
          ${escapeHtml((officeSummary.value||"").trim())}
        </div>
      `;

      // plot plan page with markings
      if (state.plan){
        for (const m of state.markers) seedLabelPosition(m);
        resolveLabelCollisions();

        const page = document.createElement("div");
        page.className = "pageBreak";
        page.innerHTML = `
          <div class="reportSectionTitle">Marked Up Plot Plan</div>
          <div class="planPrintWrap">
            <div class="planPrintStage" id="pps">
              <img src="${state.plan.dataUrl}" alt="${escapeHtml(state.plan.name)}" />
              <svg class="planPrintOverlay" id="ppo" viewBox="0 0 1000 1000" preserveAspectRatio="none"></svg>
            </div>
            <div style="padding:8px 10px; font-size:11px; color:#334155; border-top:1px solid #e5edf7; background:#fafcff;">
              ${escapeHtml(state.plan.name)}
            </div>
          </div>
        `;
        root.appendChild(page);

        const stage = page.querySelector("#pps");
        const overlay = page.querySelector("#ppo");

        for (const m of state.markers){
          const cls = markerStatusClass(m.fieldElev, m.designElev);

          const a = document.createElement("div");
          a.className = "mkAnchorPrint";
          a.style.left = m.xPct + "%";
          a.style.top  = m.yPct + "%";
          a.innerHTML = `<span>${escapeHtml(m.point)}</span>`;
          stage.appendChild(a);

          const e = document.createElement("div");
          e.className = "mkElevPrint";
          e.style.left = m.labelXPct + "%";
          e.style.top  = m.labelYPct + "%";
          e.innerHTML = `<div class="el ${cls}">${escapeHtml(m.fieldElev||"")}</div>`;
          stage.appendChild(e);
        }

        // arrow head for print
        const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
        marker.setAttribute("id", "arrowHeadPrint");
        marker.setAttribute("markerWidth", "7");
        marker.setAttribute("markerHeight", "7");
        marker.setAttribute("refX", "5.5");
        marker.setAttribute("refY", "2.5");
        marker.setAttribute("orient", "auto");
        marker.setAttribute("markerUnits", "strokeWidth");

        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", "M0,0 L7,2.5 L0,5 Z");
        path.setAttribute("fill", "rgba(239,68,68,0.92)");
        marker.appendChild(path);
        defs.appendChild(marker);
        overlay.appendChild(defs);

        for (const sr of state.slopeRows){
          const fromP = (sr.fromPoint||"").trim();
          const toP   = (sr.toPoint||"").trim();
          if (!fromP || !toP) continue;

          const mkFrom = markerByPoint(fromP);
          const mkTo   = markerByPoint(toP);
          if (!mkFrom || !mkTo) continue;

          const runM = parseNumber(sr.distanceM);
          if (!Number.isFinite(runM) || runM <= 0) continue;

          const elevFrom = bestElevForPoint(fromP);
          const elevTo   = bestElevForPoint(toP);
          if (!Number.isFinite(elevFrom) || !Number.isFinite(elevTo)) continue;

          const highIsFrom = elevFrom >= elevTo;
          const mkHigh = highIsFrom ? mkFrom : mkTo;
          const mkLow  = highIsFrom ? mkTo   : mkFrom;

          const slopeAbs = slopePercentAbs(Math.max(elevFrom,elevTo), Math.min(elevFrom,elevTo), runM);
          if (!Number.isFinite(slopeAbs)) continue;

          const A = pctToOverlay(mkHigh.xPct, mkHigh.yPct);
          const B = pctToOverlay(mkLow.xPct,  mkLow.yPct);

          const line = document.createElementNS("http://www.w3.org/2000/svg", "line");

          line.setAttribute("x1", A.x);
          line.setAttribute("y1", A.y);
          line.setAttribute("x2", B.x);
          line.setAttribute("y2", B.y);
          line.setAttribute("stroke", "rgba(239,68,68,0.88)");
          line.setAttribute("stroke-width", "2");
          line.setAttribute("stroke-linecap", "round");
          line.setAttribute("marker-end", "url(#arrowHeadPrint)");
          overlay.appendChild(line);

          const mx = (A.x + B.x)/2;
          const my = (A.y + B.y)/2;

          const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
          text.setAttribute("x", mx);
          text.setAttribute("y", my);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "central");
          text.setAttribute("fill", "rgba(239,68,68,0.98)");
          text.setAttribute("font-family", "Inter, sans-serif");
          text.setAttribute("font-weight", "900");
          text.setAttribute("font-size", "8");
          text.setAttribute("paint-order", "stroke");
          text.setAttribute("stroke", "rgba(0,0,0,0.55)");
          text.setAttribute("stroke-width", "2");
          text.textContent = `${fmtDash(slopeAbs,2)}%`;
          overlay.appendChild(text);
        }
      }

      // tables page
      const tables = document.createElement("div");
      tables.className = "pageBreak";
      tables.innerHTML = `
        <div class="reportSectionTitle">Elevation Table</div>
        <table class="reportTable">
          <thead><tr><th>Point</th><th>Field</th><th>Design</th><th>Δ (cm)</th><th>Status</th></tr></thead>
          <tbody>
            ${state.elevRows.map(r=>{
              const tol = tolByAreaCm[state.meta.area] ?? 15;
              const f = normalizeElevToMeters(r.fieldElev);
              const d = normalizeElevToMeters(r.designElev);
              const cm = calcDeltaCm(f,d);
              const status = passFail(cm,tol);
              const pill = status==="PASS" ? "pillSmall ok" : (status==="FAIL" ? "pillSmall bad" : "pillSmall");
              return `<tr>
                <td>${escapeHtml(r.pointName||"")}</td>
                <td>${escapeHtml(r.fieldElev||"")}</td>
                <td>${escapeHtml(r.designElev||"")}</td>
                <td>${escapeHtml(Number.isFinite(cm)?fmtDash(cm,1):"—")}</td>
                <td><span class="${pill}">${escapeHtml(status)}</span></td>
              </tr>`;
            }).join("")}
          </tbody>
        </table>

        <div class="reportSectionTitle">Slope Table</div>
        <table class="reportTable">
          <thead><tr><th>Segment</th><th>From</th><th>To</th><th>Run (m)</th><th>Downhill %</th></tr></thead>
          <tbody>
            ${state.slopeRows.map(r=>{
              const runM = parseNumber(r.distanceM);
              const sAbs = slopePercentAbsFromPoints(r.fromPoint, r.toPoint, runM);
              return `<tr>
                <td>${escapeHtml(r.segment||"")}</td>
                <td>${escapeHtml(r.fromPoint||"")}</td>
                <td>${escapeHtml(r.toPoint||"")}</td>
                <td>${escapeHtml(r.distanceM||"")}</td>
                <td>${escapeHtml(Number.isFinite(sAbs)?fmtDash(sAbs,2):"—")}</td>
              </tr>`;
            }).join("")}
          </tbody>
        </table>
      `;
      root.appendChild(tables);

      exportHost.appendChild(root);
      return root;
    }

    async function exportPDF(){
      if (typeof html2pdf === "undefined"){ alert("PDF export library failed to load."); return; }
      const reportEl = buildReportElement();
      await waitImagesLoaded(reportEl);

      const filename = defaultFileName("pdf");
      btnPDF.textContent = "Exporting...";
      btnPDF.disabled = true;

      try{
        await html2pdf().set({
          margin: [10,10,10,10],
          filename,
          image: { type:"jpeg", quality:0.95 },
          html2canvas: { scale: 2, useCORS:true, backgroundColor:"#ffffff" },
          jsPDF: { unit:"mm", format:"letter", orientation:"portrait" },
          pagebreak: { mode:["css","legacy"] }
        }).from(reportEl).save();
      } finally {
        btnPDF.textContent = "Export PDF";
        btnPDF.disabled = false;
        exportHost.innerHTML = "";
      }
    }

    async function sharePDF(){
      if (typeof html2pdf === "undefined"){ alert("Share requires the PDF export library."); return; }

      const reportEl = buildReportElement();
      await waitImagesLoaded(reportEl);
      const filename = defaultFileName("pdf");

      btnShare.textContent = "Preparing...";
      btnShare.disabled = true;

      try{
        const opt = {
          margin: [10,10,10,10],
          image: { type:"jpeg", quality:0.95 },
          html2canvas: { scale: 2, useCORS:true, backgroundColor:"#ffffff" },
          jsPDF: { unit:"mm", format:"letter", orientation:"portrait" },
          pagebreak: { mode:["css","legacy"] }
        };

        const worker = html2pdf().set(opt).from(reportEl);
        const blob = await worker.outputPdf("blob");
        const file = new File([blob], filename, { type:"application/pdf" });

        if (navigator.share && navigator.canShare && navigator.canShare({ files:[file] })){
          await navigator.share({ title:"Vista Geomatics – Grading Check", text:"Grading check report attached.", files:[file] });
        } else {
          await html2pdf().set({ ...opt, filename }).from(reportEl).save();
          alert("Share not available in this browser, PDF downloaded instead.");
        }
      } finally {
        btnShare.textContent = "Share PDF";
        btnShare.disabled = false;
        exportHost.innerHTML = "";
      }
    }

    // ---------- office summary ----------
    function buildOfficeSummaryText(){
      const tol = tolByAreaCm[state.meta.area] ?? 15;
      let checked=0, fails=0, worstAbs=null, worst=null, worstPoint=null;

      const failList = [];
      for (const r of state.elevRows){
        const f = normalizeElevToMeters(r.fieldElev);
        const d = normalizeElevToMeters(r.designElev);
        const cm = calcDeltaCm(f,d);
        if (!Number.isFinite(cm)) continue;
        checked++;
        if (Math.abs(cm) > tol){
          fails++;
          failList.push(`${(r.pointName||"").trim()}: ${fmtDash(cm,1)} cm`);
        }
        const abs = Math.abs(cm);
        if (worstAbs===null || abs>worstAbs){
          worstAbs = abs; worst = cm; worstPoint = (r.pointName||"").trim();
        }
      }

      const slopeLines = [];
      for (const s of state.slopeRows){
        const run = parseNumber(s.distanceM);
        const p = slopePercentAbsFromPoints(s.fromPoint, s.toPoint, run);
        if (Number.isFinite(p)){
          slopeLines.push(`${(s.segment||"Slope").trim()} (${(s.fromPoint||"").trim()}↔${(s.toPoint||"").trim()}): ${fmtDash(p,2)}% downhill`);
        }
      }

      const lines = [];
      lines.push(`Tolerance ±${tol} cm. ${checked} points checked, ${fails} out of tolerance.`);
      if (worstPoint && worst!==null) lines.push(`Largest variance ${fmtDash(worst,1)} cm at ${worstPoint}.`);
      if (failList.length) lines.push(`Out-of-tolerance: ${failList.join("; ")}.`);
      if (slopeLines.length) lines.push(`Slopes: ${slopeLines.join("; ")}.`);
      return lines.join("\n");
    }

    // ---------- events ----------
    areaSelect.addEventListener("change", () => {
      state.meta.area = areaSelect.value;
      renderTolerance();
      renderElevations();
      renderSlopes();
      renderPlan();
      saveToStorage();
    });

    function bindMetaInput(el, key){
      el.addEventListener("input", () => { state.meta[key] = el.value; saveToStorage(); });
    }
    bindMetaInput(jobNo,"jobNo");
    bindMetaInput(jobDate,"jobDate");
    bindMetaInput(community,"community");
    bindMetaInput(address,"address");
    bindMetaInput(lotBlockPlan,"lotBlockPlan");
    bindMetaInput(crewChief,"crewChief");

    btnSave.addEventListener("click", () => saveToStorage(true));

    btnReset.addEventListener("click", () => {
      if (!confirm("Clear this grading check from this device?")) return;
      localStorage.removeItem(STORAGE_KEY);
      state.meta = { area:"calgary", jobNo:"", jobDate:todayISO(), community:"", address:"", lotBlockPlan:"", crewChief:"", officeSummary:"", nextPoint:1 };
      state.plan = null;
      state.markers = [];
      state.elevRows = [];
      state.slopeRows = [];
      initDefaults();
      syncMetaToUI();
      renderTolerance();
      renderElevations();
      renderSlopes();
      renderPlan();
      saveToStorage();
    });

    btnPDF.addEventListener("click", () => exportPDF());
    btnShare.addEventListener("click", () => sharePDF());

    btnGenSummary.addEventListener("click", () => {
      officeSummary.value = buildOfficeSummaryText();
      state.meta.officeSummary = officeSummary.value;
      saveToStorage();
    });

    btnCopySummary.addEventListener("click", async () => {
      const text = (officeSummary.value||"").trim() || buildOfficeSummaryText();
      try{ await navigator.clipboard.writeText(text); }
      catch(e){
        officeSummary.focus(); officeSummary.select();
        document.execCommand("copy");
      }
    });

    officeSummary.addEventListener("input", () => {
      state.meta.officeSummary = officeSummary.value;
      saveToStorage();
    });

    planInput.addEventListener("change", async (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      try{ await setPlotPlanFromFile(f); }
      catch(err){ alert("Could not process that file. Try a smaller PDF or export it flattened."); }
      finally{ planInput.value = ""; }
    });

    btnClearPlan.addEventListener("click", () => {
      if (!state.plan) return;
      if (!confirm("Remove the attached plot plan?")) return;
      state.plan = null;
      state.markers = [];
      renderPlan();
      saveToStorage();
    });

    btnClearMarkers.addEventListener("click", () => {
      if (!state.markers.length) return;
      if (!confirm("Clear all points from the plot plan?")) return;
      state.markers = [];
      state.meta.nextPoint = Math.max(1, getMaxNumericPoint() + 1);
      renderPlan();
      saveToStorage();
    });

    // click on plan: add point (unless clicking anchor)
    planStage.addEventListener("click", (e) => {
      const anchor = e.target.closest(".mkAnchor");
      if (anchor) return;
      addPointAtClick(e);
    });

    // tap anchor: edit/remove
    planStage.addEventListener("click", (e) => {
      const anchor = e.target.closest(".mkAnchor");
      if (!anchor) return;
      editOrRemovePoint(anchor.dataset.id);
    });

    // elevations table handlers
    elevBody.addEventListener("focusin", (e) => {
      const t = e.target;
      if (t && t.tagName === "INPUT") t.select?.();
    });

    elevBody.addEventListener("input", (e) => {
      const t = e.target;
      if (!t?.dataset?.id) return;
      if (t.dataset.type !== "elev") return;
      const row = state.elevRows.find(r => r.id === t.dataset.id);
      if (!row) return;
      row[t.dataset.k] = t.value;

      // sync marker by point name
      const p = String(row.pointName||"").trim();
      if (p){
        const mk = state.markers.find(m => String(m.point||"").trim() === p);
        if (mk){
          mk.fieldElev = row.fieldElev;
          mk.designElev = row.designElev;
        }
      }

      updateComputedRow(row.id);
      renderSlopes();
    });

    btnAddRow.addEventListener("click", () => {
      state.elevRows.push({ id: uid(), pointName:"", fieldElev:"", designElev:"" });
      renderElevations();
      renderSlopes();
      saveToStorage();
    });

    btnRemoveSelected.addEventListener("click", () => {
      const ids = new Set(Array.from(document.querySelectorAll(".rowSel:checked")).map(x => x.dataset.id));
      state.elevRows = state.elevRows.filter(r => !ids.has(r.id));
      renderElevations();
      renderSlopes();
      saveToStorage();
    });

    // slopes table handlers
    slopeBody.addEventListener("input", (e) => {
      const t = e.target;
      if (!t?.dataset?.id) return;
      if (t.dataset.type !== "slope") return;
      const row = state.slopeRows.find(r => r.id === t.dataset.id);
      if (!row) return;
      row[t.dataset.k] = t.value;
      renderSlopes();
      renderPlan();
      saveToStorage();
    });

    slopeBody.addEventListener("change", (e) => {
      const t = e.target;
      if (!t?.dataset?.id) return;
      if (t.dataset.type !== "slope") return;
      const row = state.slopeRows.find(r => r.id === t.dataset.id);
      if (!row) return;
      row[t.dataset.k] = t.value;
      renderSlopes();
      renderPlan();
      saveToStorage();
    });

    btnAddSlope.addEventListener("click", () => {
      state.slopeRows.push({ id: uid(), segment:"", fromPoint:"", toPoint:"", distanceM:"" });
      renderSlopes();
      saveToStorage();
    });

    btnRemoveSlopeSelected.addEventListener("click", () => {
      const ids = new Set(Array.from(document.querySelectorAll(".slopeSel:checked")).map(x => x.dataset.id));
      state.slopeRows = state.slopeRows.filter(r => !ids.has(r.id));
      renderSlopes();
      renderPlan();
      saveToStorage();
    });

    numericKeypad.addEventListener("change", () => {
      renderElevations();
      renderSlopes();
      saveToStorage();
    });

    window.addEventListener("resize", () => {
      if (!state.plan) return;
      renderPlan();
    });

    // ---------- init ----------
    function initDefaults(){
      if (!state.meta.jobDate) state.meta.jobDate = todayISO();
      if (!Number.isFinite(state.meta.nextPoint) || state.meta.nextPoint < 1) state.meta.nextPoint = 1;

      if (state.elevRows.length === 0){
        state.elevRows.push({ id: uid(), pointName:"1", fieldElev:"", designElev:"" });
      }
      if (state.slopeRows.length === 0){
        state.slopeRows.push({ id: uid(), segment:"Front swale", fromPoint:"1", toPoint:"2", distanceM:"5.0" });
      }

      state.meta.nextPoint = Math.max(state.meta.nextPoint, getMaxNumericPoint()+1);
    }

    function syncMetaToUI(){
      areaSelect.value = state.meta.area || "calgary";
      jobNo.value = state.meta.jobNo || "";
      jobDate.value = state.meta.jobDate || "";
      community.value = state.meta.community || "";
      address.value = state.meta.address || "";
      lotBlockPlan.value = state.meta.lotBlockPlan || "";
      crewChief.value = state.meta.crewChief || "";
      officeSummary.value = state.meta.officeSummary || "";
    }

    function boot(){
      loadFromStorage();
      initDefaults();
      syncMetaToUI();
      renderTolerance();
      renderElevations();
      renderSlopes();
      renderPlan();
      saveToStorage();
    }

    boot();
  </script>
</body>
</html>
